# static

## static的含义

- static在**函数作用域**和**文件作用域**以及**类作用域**中的行为是不同的。
- 只有被用在cpp文件中，某个函数定义内才被视为在函数作用域中，一般作为局部变量。
- **static修饰的变量**，如果只在.h文件中，编译期只会认为声明了这个变量，而不会分配内存。**必须**在cpp中对该变量进行定义/初始化。或者利用其他的技巧，比如constexpr，或者inline在头文件中直接进行定义。
- cpp文件中函数定义之外的成为文件作用域
- 作用：

  - 在函数作用域内，static的意义为将被标记的局部变量的声明周期变为全局的，该变量将被放置于全局区（静态区），并在第一次用到时分配内存并初始化。
  - 在文件作用域内，static并不影响函数/变量的声明周期，而是改变其链接性，限制他们的可见性，只在当前的cpp中可见。【但是如果被定义在头文件中，那每个cpp都有一个副本。】
  - 在类作用域内，static修饰的变量具有静态存储期和外部链接性。
- 注意只有在类作用域的静态变量是所有翻译单元共享的，而函数作用域等都只在当前翻译单元可见！因此在实现单例模式时，需要把实现写在cpp中，否则每个包含该文件的翻译单元都会产生一个该变量的副本。
- static总的来说就是两个作用，一个可见性，一个生命周期。对文件和函数作用域而言，其可见性都限制在翻译的单元，不可被外部链接；而类作用域则可被所有翻译单元可见且共享。生命周期都是静态存储期。需要注意的是，非内联/模板的情况，静态变量不可在头文件中定义，否则每个翻译单元都会产生一个变量副本，引发重定义问题。
- C++中，函数/变量可以被外部多次链接（链接是指模块内部不同翻译单元的行为），有多个头文件，但只能有一份定义，就在他所处的翻译的单元内，否则可能导致重定义问题，状态不共享，不安全。
- static静态局部变量由C++标准定义了它的定义只会在**函数第一次调用时**被初始化，并且是全局唯一的。但是该全局是指模块内部，而不同模块之间的内存控件和全局数据是隔离的，如果函数被定义在头文件中被其他模块包含时，函数在其他模块中也拥有了定义，从而会产生新的副本实例。
- no-local static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的
- static和inline：
  - static 的函数是内部链接，不同编译单元可以有同名的static 函数，但该函数只对 对应的编译单元 可见。如果同一定义的 static 函数，被不同编译单元调用，每个编译单元有自己单独的一份拷贝，且此拷贝只对 对应的编译单元 可见。
  - inline 的函数是 external linkage，如果被不同编译单元调用，**每个编译单元引用／链接的是同一函数，同一定义**。
  - 内联表示共享，static内部链接表示私有。这一个是定义在头文件，一个定义在cpp中（避免命名污染）。相同点是每个cpp各有定义了。
- 类的成员函数、成员变量即使加了static，也都保持外部链接性，即可被链接访问。此时如果在多个cpp文件都有定义，在链接时就会由于找不到定义而报重复定义的错误。|==但是c++中，如果在头文件中写定义默认内联，需要注意的是内联后各自定义，不同库的静态变量就会有多份内存。==
- 注意如果给类加了导出符号，那就需要有类外定义。如果一个纯头文件类（函数全部内联/模板），不能加导出符号，会因为找不到定义报错。
