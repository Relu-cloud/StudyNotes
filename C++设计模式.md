# 观察者模式

它的优点就是观察者和被观察者之间是抽象耦合的，你可以看一下上述的LiSi和HanFeiZi类，而且也符合单一职责原则，每个类的职责都单一，通过Observer和Observable将单一职责的类串联起来，形成完美的触发机制。

## 意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

## 动机

将一个系统设计成一系列相互协作的类有一个常见的副作用：需要维护相关对象之间的一致性。

观察者模式定义一种交互，即发布-订阅：

- 一个对象当自身状态发生改变时，会发出通知，但是并不知道谁是他的接收者，但每个接收者都会接收到通知，这些接受者称为观察者。
- 作为对通知的响应，每个观察者都将查询目标状态，然后改变自身的状态以和目标状态进行同步。

## 结构

![image-20230830095300368](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20230830095300368.png)

## 参与者

Subject：目标，知道它的观察者，提供注册和删除观察者对象的接口

Observer：观察者，为那些在目标发生改变时需获得通知的对象定义一个更新接口

ConcreteSubject：具体目标，存储对象状态，状态改变时，向各个观察者发出通知

ConcreteSubject：具体观察者，维护一个指向ConcreteSubject对象的引用，存储有关状态，实现更新接口update，使自身状态与目标的状态保持一致

# 抽象工厂模式

## 工厂模式的优点

工厂模式的显著优点在于，**可以在运行时动态创建不同的C++类型对象**，从而很方便的去多态不同的行为。另外，工厂可以**包装一系列对象创建时需要的逻辑**，这是利用C++的封装特性。

## 定义

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

## 工厂方法

工厂方法模式是对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不在负责具体的产品生产，==而是只制定一些规范，具体的生产工作由其子类去完成。==在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。

# 应用实例：

工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

# 使用场景

==我们掌握一种思想，就是在创建一个对象时，需要把**容易发生变化的地方给封装起来**，来控制变化（哪里变化，封装哪里），以适应客户的变动，项目的扩展。==

**如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。**

在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。比如椅子可能既要和维多利亚风格的桌子互动，也要与现代风格的桌子互动，可以考虑抽象一个基类的椅子，由工厂类去创建维多利亚系列的桌子椅子

==一个类仅负责一个类型产品的交互，可以是不同抽象层级的，比如可以是维多利亚风格的家具（包括桌子椅子等，但是对于这个类而言，他对外负责的就是维多利亚风格的家具），她下面可以组装具体的家具构件。==

工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂

其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品

举个例子：

- 编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联(耦合)
- 后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事;
- 这种情况下，就需要将创建实例的工作从调用方(A类)中分离，与调用方「解耦」，也就是使用工厂方法创建实例的工作封装起来(「减少代码重复」)，由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，「而降低调用者因为创建逻辑导致的错误」;

# 模板模式

在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。延迟反射

# 策略模式

定义算法族

# 责任链模式

很多对象由每一个对象对其下家的引用而连接起来形成一条链。 请求在这个链上传递，直到链上的某一个对象决定处理此请求。可以自定义处理结果是否干扰

**责任链模式的优点**就是将请求和处理分开，请求者不知道这个Request到底是谁处理的，处理的人也不需要知道是谁调用的，**缺点**就是，如果责任人太多了，链式调用，类似递归，逻辑会比较复杂，加上可能对Request的处理需要遍历所有的处理者，对性能也不友好。建议在具有少数处理者的情况下使用责任链模式，或者对 setNext 设置一个阈值。

# 命令模式

命令模式是对命令进行封装，由调用者发起命令请求，接收者执行请求。当调用执行某个操作比如调用者编辑文档时，首先执行打开文档命令，打开文档命令内接收者文档会执行open操作；然后执行编辑文档命令，编辑文档命令内有个接收者成员变量文档执行edit操作；最后执行关闭文档命令，关闭文档命令内文档执行close操作。

换句话说，命令模式将不同的请求逻辑封装成**不同的请求对象 **（命令）, 以便进行请求的撤销、修改、定制。调用者通过调用不同的命令对象去完成需求。

## 适用场景

- 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。比如BIM中开启一个命令时开启一个事务以便进行回退，真正执行命令有专门的执行器editor。
- 在需要支持撤销和恢复撤销的地方，如GUI、文本编辑器等。
- 需要用到日志请求、队列请求的地方。
- 在需要事务的系统中。命令模式提供了对事物进行建模的方法，命令模式有一个别名就是Transaction。

## 优点

- 命令模式使得发起命令的对象和真正实现命令的对象完全解耦。
- 更好的扩展性，如果命令的发起对象和实现对象已经完成解耦，因此可以很容易的扩展新的命令，需要实现的命令进行适配，在需求相同的部分，新命令可以适用与旧命令相同的接收器，提高代码复用率。
- 额外的功能，命令模式可以提供诸如宏命令（组合命令）、队列请求、日志请求等额外操作

# CBD架构模式

- **CBD（核心Core+行为Behavior+驱动Driver）**架构模式，从底层开始，框架就采用核心+行为+驱动的架构体系，核心只保留了最关键的部分，并在重要位置设置标签用以标记，其他功能都采用行为扩展和驱动的方式进行组合。开发人员可以根据需求，在某个标签位置进行行为扩展或替换，可以方便的定制框架底层。也可以在应用层添加应用标签和应用行为。**而标签位置类似AOP概念中的切面，行为都面向这个切面进行编程**

# AOP面向切面编程

AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。

# 架构体系内常用组成部分命名

- Dispatcher，Scheduler解析调度程序

- Exception 系统基础异常类

# OSI七层系统模型

- OSI: open system interconnection 开放式系统互联参考模型

  | 层级                   | 所属TCP/IP四层模型概念 | 功能                                                         |
  | ---------------------- | ---------------------- | ------------------------------------------------------------ |
  | 应用层(Application)    | 应用层                 | 各种应用程序的协议，为应用程序提供网络服务                   |
  | 表示层(Presentation)   | 应用层                 | 信息的语法语义、以及他们之间的关联，如加密解密、压缩解压缩   |
  | 会话层（Session）      | 应用层                 | 建立、维护、管理会话连接，不同机器的用户之间建立以及管理会话 |
  | 传输层 (Transport)     | 传输层                 | 接受上一层数据、分割整理数据，保证这些数据有效到达对端       |
  | 网络层（NetWork）      | 网络层                 | 控制子网的运行，如逻辑编址、分组传输和路由选择               |
  | 数据链路层（DataLink） | 数据链路层             | 物理寻址，同时将原始比特流转变为逻辑传输线路                 |
  | 物理层（Phisical）     | 数据链路层             | 比特流传输                                                   |

# 有限状态机

**有限状态自动机**：是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。状态存储关于过去的信息，就是说：它反映从系统开始到现在时刻的输入变化。转移指示状态变更，并且用必须满足确使转移发生的条件来描述它。动作是在给定时刻要进行的活动的描述。有多种类型的动作：

- 进入动作（entry action）：在进入状态时进行
- 退出动作（exit action）：在退出状态时进行
- 输入动作：依赖于当前状态和输入条件进行
- 转移动作：在进行特定转移时进行

FSM（有限状态机）可以使用状态转移图来表示。此外可以使用多种类型的状态转移表。下面展示最常见的表示：当前状态（B）和条件（Y）的组合指示出下一个状态（C）。![image-20231108110808176](C:\Users\CARRYCHOU\Pictures\Screenshots\image-20231108110808176.png)

# 单例模式

单例类和static工具类的区别在于，单例可以存一些私有的成员变量表示该单例对象的全局属性内容，他除了可以管理一些存粹的静态工具方法之外，也还可以做一些**实时的全局数据逻辑的管理和执行（类似于限制作用域的全局上下文类）**。比如BIM中上下文面板管理单例存储当前有哪些entry在栈上，从而进行查找和handler的创建。

# 适配器模式

**如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性**。

1. 确保至少有两个类的接口不兼容：
   - 一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性**服务**类。
   - 一个或多个将受益于使用服务类的*客户端*类。
2. 声明客户端接口， 描述客户端如何与服务交互。
3. 创建遵循客户端接口的适配器类。 所有方法暂时都为空。
4. 在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。
5. 依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。
6. 客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。

~~~cpp
// 假设你有两个接口相互兼容的类：圆孔（Round­Hole）和圆钉（Round­Peg）。
class RoundHole is
    constructor RoundHole(radius) { …… }

    method getRadius() is
        // 返回孔的半径。

    method fits(peg: RoundPeg) is
        return this.getRadius() >= peg.getRadius()

class RoundPeg is
    constructor RoundPeg(radius) { …… }

    method getRadius() is
        // 返回钉子的半径。


// 但还有一个不兼容的类：方钉（Square­Peg）。
class SquarePeg is
    constructor SquarePeg(width) { …… }

    method getWidth() is
        // 返回方钉的宽度。


// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适
// 配器对象作为圆钉。
class SquarePegAdapter extends RoundPeg is
    // 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。
    private field peg: SquarePeg

    constructor SquarePegAdapter(peg: SquarePeg) is
        this.peg = peg

    method getRadius() is
        // 适配器会假扮为一个圆钉，其半径刚好能与适配器实际封装的方钉搭配
        // 起来。
        return peg.getWidth() * Math.sqrt(2) / 2


// 客户端代码中的某个位置。
hole = new RoundHole(5)
rpeg = new RoundPeg(5)
hole.fits(rpeg) // true

small_sqpeg = new SquarePeg(5)
large_sqpeg = new SquarePeg(10)
hole.fits(small_sqpeg) // 此处无法编译（类型不一致）。

small_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)
large_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)
hole.fits(small_sqpeg_adapter) // true
hole.fits(large_sqpeg_adapter) // false
~~~

- [桥接](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
