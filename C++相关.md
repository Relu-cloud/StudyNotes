# C++操作系统

- 一个由C/C++编译的程序占用的内存有以下几个部分：

  > - 栈区（stack）— 程序运行时由编译器自动分配，存放函数的参数值，局部变量的值等。
  >
  > - 堆区（heap） — 在内存开辟另一块存储区域。
  >
  > - 全局区（静态区）（static）—编译器编译时即分配内存。【全局变量和全局静态变量、**类的静态数据成员**在编译时即分配内存并初始化；局部静态变量则在第一次用到时分配内存并初始化】
  >
  >   全局变量和静态变量的存储是放在一块的，
  >
  >   **初始化**的全局变量和静态变量在一块区域，
  >
  >   **未初始化**的全局变量和未初始化的静态变量在相邻的另一块区域。
  >
  >   （在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了）
  >
  >   程序结束后由系统释放。
  >
  > - 文字常量区 —常量字符串就是放在这里的。常量区是全局区中划分的一个小区域，里面存放的是常量，如**const修饰的全局变量**、字符串常量等
  >
  > - 程序代码区—存放函数体的二进制代码。
  >
  > - 按进程来讲，他的内存区里是都有各自的代码段、数据段、栈区和堆区的吧，即便是两个不同的进程链接了同一个so库，那也是两份代码在两个进程的代码段里吧，包括so库里的全局数据，也应该是在两个进程各自的全局数据区里，互不影响的。不同模块/库之间数据不共享，开放访问但不开放直接写（copy on write的思想，要写就自己拷贝一份去写）。

- 1Mb等于1024*1024 = 1048576字节。即2^20。在16进制中，需要进5位。

- 一个指针在64位系统中占8个字节，32位系统中占4个字节。指针本身是一个地址描述，64位系统中需要8个字节的描述才能标识所有地址。这个指针指向了某一个字节的地址。

# C++常用语法

- C++输出中文乱码时，是因为cmd的编码与mingw编译器输出编码不同。cmd默认是gbk编码，而mingw编译器输出内容默认使用utf-8编码。解决方法如下：
  - 在命令行运行chcp 65001，暂时有用
  - 在C++源代码添加 system("chcp 65001");，控制台会显示执行chcp的返回文本
  - 在源代码添加#include <windows.h> SetConsoleOutputCP(65001);
  - 使用CLion的话，直接在控制台的右下方修改编码方式为GBK就能正确解析了

- C++函数返回一个大括号里面带有多个值比如{1,2}时，时使用了一种列表初始化。相当于返回了一个带有两个值的列表std::vector<double> 

- sizeof()是计算**==字节数==**，sizeof(array)/sizeof(type)可以知道数组个数

- constexpr和const区别：

  - **`constexpr`**：用于定义编译期常量和编译期计算的函数。它确保表达式在编译期计算，从而提高性能和安全性。

  - **`const`**：用于定义运行时常量和不可变的值。它仅表示变量的值在初始化后不可改变，但不保证在编译期计算。

- strlen()返回字符串长度

- C++17 if初始化语句，结构化绑定==（结构化绑定：通过对象的元素或成员初始化多个实体。）==用法：

  - **==if 初始化语句==**

    ~~~C++
    if (int a = f(); a != 1) // 若编译器确知变量作用域限于if块，则可更好地优化代码
    {
            // 代码块A
    	cout << a << endl;
    } 
    else if (int b = g(); b != 2) 
    {
            // 代码块B
            a += b;
            cout << a << endl;
    }
    else 
    {
            // 代码块C
            a -= b;
            cout << a << endl;
    }
    ~~~

- C++中set对象的insert()方法可将元素添加到set容器中，语法格式如下：**==pair <iterator, bool> insert(const value_type &val)==**
  - 其中val表示要添加的新元素，该方法的返回值为pair类型，pair包含2个数据，一个**迭代器**和一个**布尔值**
  - 当向set容器添加元素成功时，该迭代器指向set容器新添加的元素，bool类型的值true
  - 若添加失败。即证明原set容器中已存在相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时bool类型为false

- C++的iterator：

  C++的迭代器按定义方式有以下四种：

  > 正向迭代器：容器类名::iterator 迭代器名;
  >
  > 常量正向迭代器：容器类名::const_iterator 迭代器名;
  >
  > 反向迭代器：容器类名::reverse_iterator 迭代器名;
  >
  > 常量反向迭代器：容器类名::const_reverse_iterator  迭代器名;

  通过迭代器可以读取它指向的元素，`*迭代器名`表示迭代器指向的元素，通过非常量迭代器还能修改其指向的元素（通过++）。

- string初始化可以等于，也可以直接跟括号，也可以(数字，字符)，例子如下：
  - string s1 = "ywb";
  - string s2(s1);
  - string s3 = s2;
  - string s4("yangwen");
  - string s5(10, 'c');  // char用单引号，不能用双引号

- C++中i++与++i都是自增，但表达式的值不同，++i中i的值自增，表达式的值是i的新值；但i++中，虽然i自增，但表达式的值是i的原始值。

- C++中*声明指针，使用时表示取值；&使用时表示取址。
  - 在函数传入形参时，一般是传入参数副本，此时改变该副本的值对原值没有影响；但可以通过副本修改其他值（比如通过指针副本修改指针指向的值*p = 456），此时指针指向的值会被改变。但若使用int value=456;p=&value，在函数外部不会起任何作用
  - 若传入引用，则可以直接就地修改，比如传入int* &p, 此时int value; p = &value;直接修改p指向的地址；

- C++中**#ifndef**是“if not define”的简写，是宏定义的一种，确切的说是预处理功能中的三种（宏定义，文件包含和条件编译）中的第三种。作用如下：

  #ifndef 标识符

  程序段1

  #else

  程序段2

  #endif

  上述程序的意思是，若标识符未被定义，则编译程序段1，否则编译程序段2。最后借一个#endif

  **实际上是通过某种是否被定义的条件，控制编译语句的范围，是调试的一种手段**

- #pragma once的作用是确保头文件只被编译一次，以避免重复定义和编译错误。当编译器在编译源文件时遇到“#pragma once”时，会在编译之前先检查该头文件是否已经被包含过，如果已经被包含，则跳过该头文件的编译。

  **这实际上是一种头文件保护机制，但与传统的头文件保护机制#ifndef和#define不同，#pragma once不需要手动定义唯一标识符，也不需要手动定义#endif结束标记。但是#pragma once只是一种编译器特定的优化指令，不是标准的C++语法，虽然被大多数主流编译器支持，但在某些情况下可能无法正常工作。**

  - 扩展：C++中头文件通常包含函数、类、变量等定义和声明，这些定义和声明可以被多个源文件使用，但当一个头文件被多次包含时，就会导致同样的定义和声明被多次编译，从而引发编译错误，因此需要头文件保护机制来确保头文件只被编译一次。具体来说，在头文件的开头加入一个#ifndef预处理指令，以判断一个标识符是否已经被定义过，如果这个标识符没有被定义过，则说明这是第一次包含该头文件，此时定义这个标识符并继续编译；反之，说明该头文件已经被包含过了，直接跳过编译。

- 一般C的老库都有.h后缀，而标准的C++头文件没有.h扩展名，一般一个老的.h扩展名的库文件，比如iostream.h，在新标准后的标准库中都有一个不带.h的扩展名对应，区别有两点：

  - 有时C++的新库命名上会加一个c的前缀表示来自于c，比如cmath
  - c的很多.h库里面定义的所有类以及对象都在全局空间里，而C++把这些都扔进了“std”的名字空间中，需要使用using namespace std;调用

  **然而有一个特别的string，C++的string与C的string.h没有任何关系**

  **自己写的头文件是必须加.h的**

- 使用预处理包含指令#include可以引用用户和系统头文件，形式有以下两种：
  - #include <file> 这种用于引用系统头文件，他在系统目录的标准列表中搜索名为file的文件
  - #include "file" 这种用于引用用户头文件，他在包含当前文件的目录中搜索名为file的文件

- vector声明时长度预设，可以通过vector容器类的构造函数实现
  - std::vector<int> v0; // **==不指定长度，默认长度为0，添加一个元素即会促发容器扩张==**,string中，声明一个string也默认长度为0
  - std::vector<int> v1(3); 长度为3，默认值为0
  - std::vector<int> v(5,2);长度为5，默认值2

- 在C++中，指定形参为const表示该形参在函数体中不能被修改

- C++通过有参构造函数实例化类时，直接在声明对象后面接括号，内填参数值。

  CLOCK b(20, 5, 2);

- vector的遍历

  vector<POINT> m_testpoint

  - 第一种遍历方式，下标

    for(int i=0;i<m_testpoint.size();i++){

    cout<<m_testPoint[i].x;

    }

  - 第二种遍历方式，迭代器

    for (vector<Point>::iterator iter=m_testPoint.begin());iter!=m_testPoint.end();iter++)

    {

    cout<<(*iter).x;

    }

  - 第三种遍历方式，auto关键字

    for(auto iter=m_testPoint.begin();iter!=m_testPoint.end();iter++){

    cout<<(*iter).x;

    }

    **也可以如下，范围for循环，注意这种方式直接取vector内元素的副本，无法修改vector内元素。**

    for (auto it:m_testPoint){

    cout<<it.x;

    }
    
    **如果要修改，在声明时要用引用，auto &it**

- C语言中，结构体是一片连续的内存空间，**可使用=做赋值操作**，底层用到的就是memcpy；如果结构体中有指针变量；操作后，两个指针指向的同一块区域，而不会分配新的区域。

- memcpy(), memset(), memcpy_s(), memset_s()

  - memcpy()

    内存拷贝

    ~~~cpp
    extern void* memcpy(void* dest, void*src, unsigned int count);
    ~~~

    由src所指向内存区域赋值count个字节到dest指向的内存区域

  - memset()

    在内存级别的值填充

    ~~~C++
    void *memset(void *str, int c, size_t n)
    ~~~

    将要被设置的值c填充到str指向的内存块，填充字符数为n

    **==c以int形式传递，但是函数在填充内存块时使用该值的无符号字符型时==**

    （看起来很适合vector的批量赋值）

  - memcpy_s与memset_s

    上述两个函数的safe版，因为内存拷贝或填充可能超出限定造成无法预料的错误，加了一个参数限制拷贝/填充的最大字符数

- C++中struct和class的作用i相同，都是用于定义类，区别仅仅在于结构体内默认访问权限时public，而class定义的private。

  而定义类的时候，C++编译器会为每个类自动加上默认构造函数、拷贝构造函数以及赋值操作函数oprerator=，此时通过=号操作时，a=b即a.operator=(b); **operator=()**函数内的实现细节为：**对于基本类型，直接拷贝‘对于自定义类型，调用拷贝构造函数拷贝**,**因此对于同一个类的不同对象，可以通过=直接赋值**

- C++遇到重定义默认参数的错误，**往往是因为在函数的声明和定义同时给参数设定了默认值**。一般在C++给出函数默认值会在声明原型时给出，而在函数定义中不能同时加上默认值。

- C++同样使用\\反斜杠进行换行

- 报错：没有与这些操作数匹配的<<运算符。可能原因：

  - 有类型忘记#include，比如使用string类型却忘记include <string>
  - cin或者ofstream对象未声明
  - **注意，虽然C++的<iostream>隐式包含了std::string，所以有时很容易忘记引入<string>，但在使用<< >>等操作符时会引发问题**

- C++的string类与C常用的char数组：

  - string类对象可以对象之间赋值（**拷贝构造函数**），char数组之间不能赋值，需要调用strcpy()常规函数，strcpy(A, B)
  - string类重载了+操作符实现字符串之间的拼接A += B；char数组时使用strcat()常规函数，strcat(A, B)
  - string类使用.size()方法返回字符串长度；字符数组使用strlen()常规函数 strlen(A)
  - 为了与C兼容，C++对string对象提供c_str()成员函数，把string对象转换为C中的字符串样式，以char*形式返回string内含字符串。

- struct初始化：

  结构体是常用的自定义构造类型，是一种很常见的数据打包方法。结构体对象的初始化有多种方式，分为顺序初始化、指定初始化、构造函数初始化。假如有如下结构体。

  ```cpp
  struct A {
  	int b;
  	int c;
  };
  ```

  - 顺序初始化

    A a = {1, 2};书写简约，但相对于指定初始化，无法变更数据成员初始化顺序，灵活性较差

  - 指定初始化

    // 点号+赋值符号
    A a = {.b = 1, .c = 2};

    // 冒号
    A a = {b:1, c:2};

    两种实现方式，前者是C99标准引入，后者是GCC扩展，但有些编译器不支持指定初始化，比如Visual C++

  - 构造函数初始化

    struct A {
    	A(int b,int c) {
    		this->b=b;
    		this->c=c;
    	};
    	int b;
    	int c;
    }

    **注意：** struct 如果定义了构造函数的话，就不能用大括号进行初始化了，即不能再使用指定初始化与顺序初始化了。


- ==需要注意的是，不能再结构体声明中初始化结构体成员，因为结构体声明只是**创建一个新的数据类型，还不存在这种类型的变量**，他只声明一个结构体看起来是什么样子的，所以不会再内存中创建成员变量，只有通过定义该结构体类型的变量来实例化结构体，才有地方存储初始值。**与之不同的是C++11之后引入了类的成员变量的默认初始化，可以在定义中设置成员变量的默认值，从而让类实例化后指定的成员变量具有指定的默认值。**==

- struct赋值

  **注意：** ==结构体变量的赋值是不能采用大括号的方式进行赋值的==，这是因为如果一个结构体不是聚合类，那么**所有的大括号初始化会转为调用相应的构造函数**来进行初始化，赋值同理，只有与构造函数参数一致的大括号才可以成功赋值

  **在聚合类结构体中，即并没有自定义构造函数，大括号中的值会按照结构体中变量的声明顺序进行一对一的赋值**.

  - 使用memset对结构体变量做置空操作

    // 按照编译器默认的方式进行初始化（如果 a 是全局静态存储区(static)的变量，默认初始化为0，如果是栈上的局部变量，默认初始化为随机值）
    A a; 
    memset(&a,0,sizeof(a));

  - 依次给每一个结构体成员变量进行赋值：

    ```cpp
    A a; 
    a.b = 1;
    a.c = 2;
    ```

  - 使用已有的结构体变量给另一个结构体变量赋值。**也就是说结构体变量之间是可以相互赋值的**。

  ```cpp
  A a = {1,2};
  struct A a1;
  a1 = a; 				// 将已有的结构体变量赋给 a1
  ```

- vector快速将所有元素置0：

  - vector初始化时采用vector vct(num, 0); 默认全部赋值为0
  - 采用std::fill函数 std::fill(v.begin(), v.end(), 0);
  - 也可以迭代器或者索引循环赋值
  - 或者memset置0 
    - memset是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。
    - 函数原型如下：
      void *memset(void *s, int ch, [size_t](https://www.baidu.com/s?wd=size_t&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) n);
    - 将s中前n个字节 （typedef unsigned int [size_t](https://www.baidu.com/s?wd=size_t&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)）用 ch 替换并返回 s，将ch设置为0即可，返回指向s的指针

- vector中end()方法和back()方法：

  **vector::end()返回的是vector最后一个元素后的”结束元素“**

  **vector::back()返回的是最后一个元素**

- vector的索引：用find拿到迭代器后，用std::distance算迭代器之间的距离

  > vector\<double\>::iterator ite1 = find(vec_dis.begin(), vec_dis.end(), vec_dis1[0]);
  > vector\<double\>::iterator ite2 = find(vec_dis.begin(), vec_dis.end(), vec_dis1[1]);
  > vector\<double\>::iterator ite3 = find(vec_dis.begin(), vec_dis.end(), vec_dis1[2]);
  > auto index1 = std::distance(vec_dis.begin(), ite1);
  > auto index2 = std::distance(vec_dis.begin(), ite2);
  > auto index3 = std::distance(vec_dis.begin(), ite3);


- C++跳出多层循环的办法：

  - 使用goto

    for (int i = 0; i < MAX1; i++)
    {
        for (int j = 0; j < MAX2; j++)
        {
            if (condition)
            {
                symbol = 1;
                goto outloop;
            }
        }
    }
    outloop:
    //somecode

  - 写成函数用return

  - 直接在break前修改外层循环的条件

    for(int i = 0; i < MAX1; i++)
    {
        for(int j = 0; j < MAX2; j++)
        {
            if(condition1)
            {
                symbol = 1;
                i = MAX1;
                break;
            }
        }
    }

  - 在外层循环设置判断条件

    内层循环判断满足条件修改标志后 外层循环进行判断：

    for(;symbol != 1 && condition1;)
    {
        for(;symbol != 1 && condition2;)
        {
            for(;symbol != 1 && condition3;)
            {
                if(condition)
                {
                    symbol = 1;
                }
            }
        }

- C++的goto语句允许把控制无条件转移到同一函数内的被标记的语句。写法如下

  ~~~C++
  goto label;
  ..
  .
  label:
  statement;
  ~~~

  **在这里label是识别被标记语句的标识符，可以是任何除C++关键字以外的纯文本。statement是标记语句，可以是任何语句，放置在==放置在标识符和冒号后面==**

  **==goto语句一个很好的作用是推出深嵌套循环==**

  ~~~C++
  for(...){
      for(...){
         	while(...){
              if(...) goto stop;
          }
      }
  }
  stop:
  cout <<"Error in program.\n";
  ~~~



- C++中双冒号的用法：

  - 表示“域操作符”：

    声明了一个类A，类A里面声明了一个成员函数void click()，但没有在类的声明里边给出click的定义，那么在类外定义click时，就要写成void A::click()，表示这个click()函数时类A的成员函数。

  - 直接用在全局函数前，表示是全局函数。例：在VC中，你可以在调用API函数里，在API函数名前面加：：

  - 表示引用成员函数及变量，作用域成员运算符，==可以在不实例化对象，而直接在类声明外调用其成员函数/变量==

    ```cpp
    例：
    System::Math::Sqrt() // 相当于 System.Math.Sqrt()
    ZSoft::GePoint2d::kOrigin // 直接类外调用GePoint2d下的kOrigin
    ```

- C++==单冒号==的用途/一般使用方式

  - 在类内的`public:/private:/protected:`
  - 在参数初始化列表的时候`ClassName(pram):ValueName1(), ValueName2(){}`
  - 在派生类的构造函数的书写的时候`DerivedClassName(pram): BaseClassName(pram){}`
  
- C++类构造函数初始化列表：

  构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式.**==注意const成员或引用类型的成员只能初始化，不能对他们赋值==**

  ~~~C++
  class CExample
  {
  public:
      int a;
      float b;
      //构造函数初始化列表
      CExample(): a(0), b(8.8) {}
      //构造函数内部赋值
      CExample()
      {
          a = 0;
          b = 8.8;
      }
  };
  ~~~
  
- 类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

  构造函数的名称与类的名称是完全相同的，**==并且不会返回任何类型，也不会返回 void==**。构造函数可用于为某些成员变量设置初始值。

  ~~~C++
  #include <iostream>
  using namespace std;
  class Line
  {
     public:
        void setLength( double len );
        double getLength( void );
        Line();  // 这是构造函数
     private:
        double length;
  };
  // 成员函数定义，包括构造函数
  Line::Line(void) // 前面没有返回值类型
  {
      cout << "Object is being created" << endl;
  }
  void Line::setLength( double len )
  {
      length = len;
  }
  ~~~

  

- C++中typedef用法详解

  - 定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。

    typedef char* PCHAR;

    PCHAR pa, pb;

  - ==用在旧的C的代码中，帮助struct==。

    typedef struct tagPOINT

    {

    int x;

    int y;

    }POINT;

    POINT p1;

  - 用typedef定义与平台无关的类型

    用typedef来定义与平台无关的类型。
    比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：

    > typedef long double REAL; 

    在不支持 long double 的平台二上，改为：

    > typedef double REAL; 

    在连 double 都不支持的平台三上，改为：

    > typedef float REAL; 

    也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。

    **类似于把类型变量化**


- 关于const：

  - C++的const机制中对顶层const和底层const进行了区分，具体而言，**顶层 `const` 表示指针本身是个常量，指针地址不能修改；底层 `const` 表示指针所指的对象是一个常量，指针指向对象不能修改**。==注意在默认的类型转换中，可以添加const，但不能直接移除const。从左往右为从底到顶==

    ~~~cpp
    - const int *pOne; // 底层const，指向的对象不能被修改
    - int * const pTwo; // 顶层const，指针代表的地址不能被修改
    - const int *const pThree; // 底层const+顶层const，指针代表的地址以及指向的对象都不能被修改
    ~~~

  - ==默认情况下，普通成员函数的隐式形参之一是一个底层非const，顶层const的this指针`A * const this`，因为不可以修改this指针代表的地址。而常成员函数（即const成员函数）的隐式形参是一个底层const+顶层const的this指针`const A* const this。`==
  - 在基于对象/指针调用对象方法时，对于this指针的形参，会基于对象/指针的不同类型传入不同实参，**如果对象为const，传入的实参为const A* this; 如果对象为非const，传入的实参为A* this**。然后在实参类型转换为形参类型中，对象为非const下的A* this可以任一转换添加const，因此可以调用全部方法；==但对象为const下的this（const A* this）在转换为普通非const函数的形参（A* const this）时，会丢失底层const，从而可能允许this指向对象发生改变，这是C++不允许的，因此编译报错。==
  - 然而加上mutable修饰符的数据成员，对于任何情况下通过任何手段都可修改，自然此时的const成员函数是可以修改它的。

- const做形参时，表示该形参在函数体内不能被改动，但实参可以传递普通类型，也可以传递const 普通类型。

  有一种性能较好的写法是f(const A & a)，其中==&是为了引用传递，防止值传递赋值数据；const是为了保护数据不被改动，const &防止传值时拷贝构造函数的调用开销==

- const与constexpr:

  - const实际上不能代表“常量”，他是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改。其值可以在运行时也可以在编译时指定。

  - constexpr可以用来修饰**变量、函数、构造函数**。一旦以上任何元素被constexpr修饰，那么等于告诉编译器“==请大胆地将我堪称编译时就能得出常量值的表达式去优化我==”

    **实际上constexpr另外一个特性是，即使程序员欺骗了他，并没有传入常量参数，他也不会终止编译，只是会将计算任务留给运行时**

- C++函数后加const：

  在类的成员函数中，有一些成员函数不改变类的数据成员，即“只读”函数；而有一些函数则需要修改类数据成员的值。因此，把不改变数据成员的函数都加上**const**关键字标识，能增加函数的可靠性与可读性。

  - ==非静态成员函数后面加const表示成员函数隐含传入的this指针为const指针，因为隐含了对this指针的const引用==

  - 唯一的例外是对于mutable修饰的成员

  - ~~~C++
    char getData() const{
        return this->letter;
    }
    ~~~

  - 


- GSL与STL：

  - GSL(GNU Scientific Library)是一个用C写成的用于科学计算的库
  - STL（Standard Template Library）是C++标准库的一部分，标准模板库，C++对模板支持的很好，STL就是借助模板把常用的数据结构和算法都实现了一遍，并做到了数据结构和算法的分离。
  - 使用**gsl::span**\<char\>可以简单安全的访问字符串而不需要关心序列如何分配与存储

- static_assert与assert：

  assert作用是先计算表达式expression，如果值为0，则先向stderr打印一条出错信息，然后调用abort终止程序运行，有**静态断言和动态断言**。

  - static_assert(常量表达式，要提示的字符串)

    使用其可以在编译期发现更多的错误，用编译器强制保证一些契约，并帮助我们改善编译信息的可读性，尤其用于模板的时候。

    **编译器在遇到一个static_assert语句时，通常立刻将其第一个参数作为常量表达式进行演算，但如果该常量表达式依赖于某些模板参数，则延迟到模板实例化时再进行演算，这就让检查模板参数成为了可能。**

  - assert是运行期断言，在发行版本中assert都会被关掉

- static：

  一个变量有生命周期(存储位置，即什么时候有效，什么时候消散，永久无效)和作用域(即在哪儿有效，在哪儿暂时无效但是并没有消散)。

  - 对于局部变量，其存储在栈内存，函数结束时其声明周期随之结束永久消散，==且其作用域在函数体内，即只在函数体内有效==。
  - 对于全局变量，其存储在全局数据区，其生命周期为整个程序，直到程序退出才消散，==且其作用域也是在整个程序全部位置都有效。==
  - **但是为了频繁只在某一个局部区域使用，我们需要一个生命周期很长，但有效位置被局限的变量，这就出现了static静态局部变量。**==其存储在全局数据区，但其作用域就在函数体内。==

- C++结构体之位域：

  有些信息存储时，并不需要占用一个完整字节，只需要占用一个或几个二进制位(==一个字节有八个二进制位==)，例如存放一个开关量时，只有0、1两种状态，用一位二进位即可。为了节省存储空间，并处理简便，C提供了一种数据结构，称为“位域”。

  - 位域的定义与结构体相仿

    ~~~C++
    struct 位域结构名
    {
        位域列表 // 形式为类型说明符 位域名: 					位域长度
    };
    ~~~

  - 一个位域必须存储在同一个字节中，不能跨两个字节，如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。

  - 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节长度

  - 位域可以无为域名

- C++的类定义实际上就是一个类型声明，**后面可以跟一个该类型的变量**，==在其后面加上一个分号作为定界符能防止很多异常情况==

  ~~~C++
  int i;
  struct abc {} bcd;
  class efg {} fgh;
  enum ijk {} jkl;
  typedef struct mno {} nop;
  int i[3] {1, 2, 3};
  ~~~

- C++类的继承：

  - 访问控制和继承，派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为private，具体访问情况如下表。

    | 访问     | public | protected | private |
    | -------- | ------ | --------- | ------- |
    | 同一个类 | yes    | yes       | yes     |
    | 派生类   | yes    | yes       | no      |
    | 外部的类 | yes    | no        | no      |

  - 继承类型

    当一个类派生自基类，该基类可以被继承为public, protected或private几种类型。**我们几乎不使用protected或private继承，通常使用Public继承。**继承遵循以下规则：

    - **公有继承**：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，==基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员访问。==
    - 保护继承：当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
    - 私有继承：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员

- C++内联函数

  - C++内联函数通常与类一起使用，如果一个函数是内联的，那么在编译时，**编译器会把该函数的代码副本放置在每个调用该函数的地方**。因此对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码。
  - 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字**inline**，在调用函数之前需要对函数进行定义。**如果已定义的函数多于一行，编译器会忽略inline限定符。**

- C++匿名命名空间

  当定义一个命名空间时，可以忽略命名空间的名称，此时编译器在内部会为这个命名空间生成唯一的名字，并会为这个匿名命名空间生成一条using指令。如下：

  ~~~C++
  namespace
  {
      char c;
      int i;
      double d;
  }
  // 等同于
  namespace _UNIQUE_NAME_
  {
      char c;
      int i;
      double d;
  }
  using namespace _UNIQUE_NAME_;
  ~~~

  在匿名命名空间中声明的名称也将被编译器转换，与生成的名称绑定在一起。需要注意的是，**==这些名称具有internal属性，这与声明为static的全局名称的链接属性相同，无法通过另外的文件使用extern声明来连接。==**原因在于：在文件之外，匿名命名空间生成的\_UNIQUE\_NAME\_对别的文件是不可见的。

- extern "C"

  extern "C"的主要作用就是为了能正确实现C++代码调用其他C语言代码。加上extern会指示编译器这部分按C语言的进行编译。

- 移动构造函数与移动赋值操作符

  - 右值引用

    C++在11之前只支持对左值即有明确地址的变量进行引用，如果使用Int& i = 419;就会报编译错误，因为419是一个临时变量，属于右值。在使用右值进行传参时，比如

    ~~~C++
    void printV(std::string const& s);
    printV("hello world");
    ~~~

    函数允许接受一个常量**左值(s)**引用，因此在调用后首先将临时变量"hello wolrd"通过拷贝构造函数创建了一个左值形参，并取他的常量引用传入函数。**可以看到我们本想传入一个字符串，但却创建了两个变量，一个左值和一个右值**，如果能把目标函数的形参能设为临时变量的引用——一个右值的引用，就能节约资源。因此C++11引入了右值引用。

  - C++通过&&而不是&来声明右值引用变量，由于右值通常是一个将要销毁的对象，因此我们可以自由的将其**移动到**另一个对象中。

  - 类比拷贝构造函数，我们也可以实现一个以右值引用为参数的构造函数，实现转移的逻辑，避免每次传入右值都需要拷贝一个左值，然后进行传参。

  - 右值引用与移动语义的出现，是为了实现资源使用主体的转移，避免频繁销毁与申请，以便更高效地管理资源和避免不必要的拷贝。可以使用std::move(左值)将一个左值转换到右值，即表示该值申请的资源即将被转换使用主体。

  - **字符串字面量**与**整型字面量**在内存分配和生命周期上的处理方式有所不同。

    - 字符串字面量通常需要在程序的多个部分使用，可能跨越多个函数调用，甚至在全局范围内使用。因此，将它们存储在常量区可以确保它们在整个程序运行期间都有效。
    - 将字符串字面量存储在常量区并共享相同的字面量可以显著减少内存使用，尤其是在字符串比较多且重复使用时。
    - 字符串字面量通常是不可变的，放在常量区可以防止意外修改，保持数据的安全性和一致性。

- C++的const成员变量和引用变量都只能在构造函数初始化列表里初始化，而不能在构造函数体内初始化。==因为在进入构造函数体内时，引用变量和const变量都已经用不确定的值初始化好了，构造函数体内能做的只有赋值，而const类型和引用类型是不可以赋值的。==


- C++中explicit关键字只能用于修饰只有一个参数的类构造函数，表明该构造函数是显式的，不允许编译器做意料之外的类型转换。而相反的是implicit，隐式的构造函数当只有一个参数是，编译时会有缺省的转换操作：将构造函数对应数据类型的数据转换为该类对象，即使如果构造函数参数是整型，传入一个字符，依旧会以ASCII码值的形式转换，然后拷贝构造；或者形参是该对象的引用，传入一个整型，代码却依旧能够运行。

- C++的enum：

  枚举类型是C++中的一种派生数据类型，他是由用户定义的若干枚举常量的集合。格式为enum <类型名> {<枚举常量表>}

  ~~~C++
  enum ColorSet {RED, BLUE, WHITE, BLACK};
  enum Week {SUN, MON, TUE, WED, THU, FRI, SAT};
  ~~~

  编译系统会为每个枚举常量指定一个**整数值**，==默认状态下，该证书就是所列举元素的序列，从0开始。==也可以指定整数值（部分或全部），在指定值之前的枚举常量仍按默认值取，而指定后的枚举常量==按照依次加1的原则取值==。

  ~~~C++
  enum fruit_set {apple, orange, banana = 1, peach, grape};
  // apple = 0, orange = 1, banana = 1, peach = 2, grape = 3
  ~~~

- new和delete：

  - 调用new所包含的动作：从系统中申请一块内存，并调用此类型的构造函数。
  - 调用new[n]所包含的动作：申请可容纳 n 个对象的内存，并且对每一个对象调用其构造函数。
  - 调用delete所包含的动作：先调用相应的析构函数，再将内存归还系统。
  - 调用delete[]所包含的动作：对每一个对象调用析构函数，再释放所有内存

- 类的删除函数：

  类大多数默认定义了拷贝构造和拷贝赋值，但对于某些类这些操作时没有意义的，因此可以自定义拷贝构造和拷贝赋值的基础上，同样自定义删除这些。

  ==使用=delete关键字显式告诉编译器删除该函数==

  ==使用=default关键字显式告诉编译器指定该函数为默认构造函数/析构函数，避免还需要定义函数体增加代码行数==

  ~~~c++
  struct NoCopy{
      NoCopy()=default;      //指定使用无参的构造函数为默认构造函数
      NoCopy(const NoCopy&)=delete;  //阻止拷贝
      NoCopy &operator=(const NoCopy&)=delete; //阻止赋值
      ~NoCopy()=default; //使用无参的析构函数
  };
  ~~~

- 【智能指针，unique_ptr】make_unique:

  - make_unique 同 unique_ptr 、auto_ptr 等一样，都是 smart pointer，可以取代new 并且无需 delete pointer，有助于代码管理。

  - make_unique 创建并返回 unique_ptr 至指定类型的对象，这一点从其构造函数能看出来。make_unique相较于unique_ptr 则更加安全。

    ~~~c++
    template<typename T, typename... Ts>
    std::unique_ptr<T> make_unique(Ts&&... params)
    {
        return std::unique_ptr<T>(new T(std::forward<Ts>(params)...));
    }
    ~~~

  - std::make_unique 和 std::make_shared是三个make函数中的两个，make函数用来把一个任意参数的集合完美转移给一个构造函数从而生成动态分配内存的对象，并返回一个指向那个对象的灵巧指针。

  -    ==make_unique在实现里用传入参数new了一个新的对象，如果希望将已经生产的资源（即指针）初始化到unique_ptr中，一般要自己的声明unique_ptr并使用初始化列表赋值。==

- C++中lambda匿名表达式

  lambda匿名函数语法格式如下

  ~~~c++
  [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
  {
      函数体;
  };
  ~~~

  lambda表达式是一种在被调用的位置定义匿名函数的简便方法，比如

  ~~~cpp
  #include <algorithm>
  #include <cmath>
  
  void abssort(float* x, unsigned n) {
      std::sort(x, x + n,
          // Lambda expression begins
          [](float a, float b) {
              return (std::abs(a) < std::abs(b));
          } // end of lambda expression
      );
  }
  // 上面代码作为std::sort的第三个参数
  ~~~

  各部分含义

  - [外部变量方位方式说明符]

  > []方括号用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前lambda函数的函数体中可以使用哪些”外部变量“ 

  | 外部变量格式      | 功能                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | []                | 当前不导入                                                   |
  | [=]               | 只有一个=，以值传递方式导入所有外部变量                      |
  | [&]               | 只有一个&，以引用传递方式导入所有外部变量                    |
  | [val1, val2...]   | 以值传递方式导入val1, val2等指定外部变量，多个变量之间没有先后次序 |
  | [&val1， &val2..] | 以引用传递的...                                              |
  | [val1, &val2,...] | 混用                                                         |
  | [=, &val1,...]    | 除val1..以引用导入外，其他都以值                             |
  | [this]            | 以值传递导入当前this指针                                     |

  - （）参数列表

  > lambda既可以==捕获变量，也可以接受输入参数==，参数列表是可选的，他在大多数方面类似于函数的重载列表。

  - mutable规范

  > 通常，Lambda 的函数调用运算符是 const-by-value，但对 **`mutable`** 关键字的使用可将其取消。它不产生 mutable 数据成员。 利用 **`mutable`** 规范，Lambda 表达式的主体可以修改通过值捕获的变量。

  - 异常规范

  > 你可以使用 **`noexcept`** 异常规范来指示 Lambda 表达式不会引发任何异常。

  ~~~cpp
  // throw_lambda_expression.cpp
  // compile with: /W4 /EHsc
  int main() // C4297 expected
  {
     []() noexcept { throw 5; }();
  }
  ~~~

  - 返回类型

  > 该部分是可选的。lambda将自动推导表达式的返回类型，无需使用auto关键字。也可以指定==trailing-return-type==， trailing-return-type 类似于普通函数或成员函数的 return-type 部分。 但是，返回类型必须跟在参数列表的后面，你必须在返回类型前面包含 trailing-return-type 关键字 **`->`**。

- C++函数式宏：

  - #define BIM_DB_MEMBERS(CLASS)  定义一个函数式宏，以CLASS为参数
  - #的功能是将后面的宏参数进行字符串化操作，简单说就是在对他引用的宏变量通过替换后在其左右各加上一个双引号。
  - ##符号的功能是将宏定义中的两个字串拼接起来，从而形成一个新的字符串
  - **至于为什么加##进行分隔，举个例子容易理解，比如#define F(x) T##x##_,如果前面的##不加，则Tx##_，其中的Tx，编译器就无法识别里面的x是参数里给的x，而是Tx当成一起得了，后面的也类似，总之，加##就是为了把参数识别出来，如果在开头，只加后面的就可以了，如x##_）简单的说，##就是把参数当成不带引号的字符串进行替换，#把参数当成带引号的字符串进行替换）**
  - #和##在宏方法中，用作参数替换、在代码中，用于将代码字符串画

- 在*c++*里面，==构造函数、析构函数、赋值操作符，这些都不能被继承==。另外对于基类的**==静态成员==**，无论有多少个派生类，都只有这一个静态成员实例。

- C++11新增关键字，=default, =delete, override(覆盖), final(最终，不允许被重写了)

  **==需要注意的是，一旦某个函数(基类)被声明为了虚函数，则在所有派生类(子类中)都是虚函数，这意味着，子类也可以在派生实现多态。==**

  一般C++会提供默认的构造函数、拷贝构造函数、析构函数等，但如果自定义相应函数，编译器将不会提供。但有时我们有需要无参构造函数，自己定义势必会增加代码量，此时只需要在默认函数后加一个=default，**=default 编译器能够为这种的无参构造函数自动生成函数体，普通函数不能这样写， 带参数的构造函数也不能这样写**；

  ~~~C++
  class Animal
  {
  public:
      Animal() = default;   //编译器会提供默认的构造函数
      Animal(string name);
  private:
      string _name;
  };
  ~~~

- 禁止在构造函数和析构函数中调用虚函数

  **==如果在构造函数中调用虚函数==，由于派生对象构造时先调用基类构造函数，再调用派生类构造函数，而构造期间进入基类的构造函数时，对象类型变成了基类，而不是派生类，此时调用的仍然是基类的虚函数，不能达到多态的效果。**

  **==如果在析构函数中调用虚函数==，C++在析构时会先调用派生类析构函数再调用基类的构造函数，假设对一个派生类对象进行析构时，首先调用了派生类的析构，再屌用基类的析构时，要不调用基类虚函数未实现多态，要不调用派生类重写函数，但此时其已完成析构，会被视为未定义的值，会导致未知行为。**

- 派生类的构造函数在定义时需要首先继承父类的构造函数，最后定义的形式如A::A:B的形式。其中A继承于B。

- C++使用unorderedmap判断元素是不是在哈希表的两种方式：

  ~~~C++
  if (mp.count(查找东西))
  {
      printf("存在")；
  }
  
  // count()是一个计数方法，如果存在则=1。返回真，否则返回假
  ~~~

  ~~~C++
  if(mp.find(查找的东西) != mp.end() )
  {
      printf("存在")
  }
  ~~~

  **unordered_map的find方法返回一个迭代器，返回寻找的键在map中的位置，类似于一个指针，要得到拿到具体key与value还是要使用iter->first()与iter->second()方法**

  - 在为unodered_map添加键值对时，可以用insert()方法和emplace()方法，后者比前者效率更高。其语法格式如下：

    ~~~cpp
    template <class... Args>
        pair<iterator, bool> emplace(Args&&... args)
    ~~~

    其中，参数 args 表示可直接向该方法传递创建新键值对所需要的 2 个元素的值，其中第一个元素将作为键值对的键，另一个作为键值对的值。也就是说，该方法无需我们手动创建键值对，其内部会自行完成此工作。

    另外需要注意的是，==该方法的返回值为 pair 类型值，其包含一个迭代器和一个 bool 类型值==：

    - 当 emplace() 成功添加新键值对时，返回的迭代器指向新添加的键值对，bool 值为 True；
    - 当 emplace() 添加新键值对失败时，说明容器中本就包含一个键相等的键值对，此时返回的迭代器指向的就是容器中键相同的这个键值对，bool 值为 False。


- C++赋值表达式的值为赋值符号右边的值

- C++模板是实现泛型编程的基础，基本用法如下：

  ~~~
  template <typename T>
  T minimum(const T& lhs, const T& rhs)
  {
  return lhs < rhs ? lhs : rhs;
  }
  ~~~

  以上描述了一个具有单个类型参数T的泛型函数

  对于模板，类型参数的数量没有实际限制，以逗号分隔多个参数，**但需要保证传入的类型支持应用于类型参数的任何操作**

  ~~~C++
  template <typename T, typename U, typename V> class Foo{};
  ~~~


- C++要比较两个==字符串常量==注意不能直接使用关系运算符，因为字符串常量的变量实际上表示一个地址，直接使用关系运算符只表示判断两个地址是否相同，在C++中使用C式函数strcmp()【compare的缩写】方法是常用办法。

  ~~~cpp
  a = "this is a string";
  b = "this a new string";
  strcmp(a, b);
      //比较a,b的字典序，a<b返回负值，a=b返回0，a>b返回正值
  ~~~

  ==但是对于string类型字符串可以直接使用关系运算符比较，要求比较双方至少有一个为string类对象==

- 注意C++new是在堆中申请一块特定类型的内存，而这个内存是匿名的，只能用指针操控，因此C++的new表达式一般将结果给指针进行初始化。为了简便形式，指针的类型可使用auto进行类型推断。

- 看到一个有意思的用法：

  ~~~cpp
  class GePoint2d
  {
  public:
  	double x;
      double y;
      static const GePoint2d kOrigin; //在类声明里实例化了一个自身的对象，调用默认构造函数，表示一个原点变量
  public:
      GePoint2d(void): x(0,0), y(0.0){} // 构造函数初始化列表
  }
  ~~~


- C++的unordered_map容器与map容器仅有一点不同，即map中存储的数据时有序的，而unordered_map中存储的数据是无序的。

  ==具体来说，unordered_map与map一样，以键值对(pair类型)存储数据，存储的各个键值对的键互不相同且不允许被修改。**注意，unordered_map的键只支持基本数据类型，即必须是可哈希的，如果要自定义类型，则需要自己设计该类型对应的哈希函数和比较函数。**==

  ~~~cpp
  // 声明
  std::unordered_map<std::string,std::string> umap;
  // 声明并初始化
  std::unordered_map<std::string, std::string> umap{
      {"Python教程","http://c.biancheng.net/python/"},
      {"Java教程","http://c.biancheng.net/java/"},
      {"Linux教程","http://c.biancheng.net/linux/"} };
  // 声明并拷贝
  std::unordered_map<std::string, std::string> umap2(umap);
  //使用迭代器自定义拷贝范围
  std::unordered_map<std::string, std::string> umap2(++umap.begin(),umap.end());
  ~~~

  unordered_map的常用方法如下：

  | 成员方法                               | 功能                                                         |
  | -------------------------------------- | ------------------------------------------------------------ |
  | begin()                                | 返回指向容器中第一个键值对的正向迭代器。                     |
  | size()                                 | 返回当前容器中存有键值对的个数。                             |
  | max_size()operator[key]                | 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，==如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。==**直接使用[]插入新的键值对** |
  | find(key)                              | 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如 end() 方法返回的迭代器）。==然后使用iter->second()取值== |
  | at(key)                                | 返回容器中存储的键 key 对应的值，**如果 key 不存在，则会抛出 out_of_range 异常**。 |
  | size_type erase ( const key_type& k ); | 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。 |
  
  - unordered_map的遍历取值
  
    - 使用迭代器iterator
  
      for (map\<int, int\>::iterator it = mp.begin(); it!=mp.end();++it)
  
      {cout << it->first << "--" << it->second<<"\\t";
  
      }
  
    - 使用结构化绑定auto
  
      ~~~c++
      for (auto&[k, v]:mp)
          cout<<k<<"--"<<v<<"\t"
      ~~~
  
    - 使用auto注意用.
  
      for(auto kv:map){
      cout<<kv.first<<kv.second<<endl;
      }


- C++11的新特性std::function()

  **类模版std::function是一种通用、多态的函数封装**。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。

  **通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。**

  其用法如下：

  ~~~cpp
  std::function<outputType(inputType)> // 里面接要调用函数的输出类型和输入类型
  ~~~

  

- C++中using的用法：

  - 命名空间的预编译，不做多的说明‘

  - 别名指定，这点与typedef类似，但在如下的情况中可能更加清晰一些：

    ~~~cpp
    typedef void (*FP) (int, const std::string&);
    // 若不是特别熟悉函数指针与typedef的童鞋，我相信第一眼还是很难指出FP其实是一个别名，代表着的是一个函数指针，而指向的这个函数返回类型是void，接受参数是int, const std::string&。那么，让我们换做C++11的写法：
    ~~~

    ~~~cpp
    using FP = void (*) (int, const std::string&);
    // 我想，即使第一次读到这样代码，并且不知道 C++11 using 用法的童鞋也能很容易知道 FP 是一个别名，using 的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰。
    ~~~

  - 在子类中引用基类的成员

    ~~~Cpp
    class T5Base {
    public:
        T5Base() :value(55) {}
        virtual ~T5Base() {} // 基类析构函数要声明虚函数，这样在用多态时才会调用子类析构
        void test1() { cout << "T5Base test1..." << endl; }
    protected:
        int value;
    };
    
    class T5Derived : private T5Base {
    public:
        //using T5Base::test1;
        //using T5Base::value;
        void test2() { cout << "value is " << value << endl; }
    };
    // 基类中成员变量 value 是protected，在private继承之后，对于外界这个值为 private，也就是说T5Derived的对象无法使用这个 value。如果想要通过对象使用，需要在public下通过 using T5Base::value 来引用，这样 T5Derived 的对象就可以直接使用。同样的，对于基类中的成员函数 test1()，在private继承后变为 private，T5Derived 的对象同样无法访问，通过 using T5Base::test1 就可以使用了。
    ~~~

- C++的类型转换（C++的cast是借用冶金中铸造注模的概念，把液态的金属导入成型的模板中叫cast,变成中把一段数据装成某种数据类型，让数据具有某种类型的过程叫cast）：

  - static_cast和dynamic_cast是C++中的两个类型转换操作符，它们的作用和用法略有不同。 **static_cast可以用于基本数据类型之间的转换，也可以用于父类和子类之间的转换，但是它在进行类型转换时不进行运行时类型检查**。 如果转换的类型是不安全的，可能会导致未定义的行为。**之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。而dynamic_cast在进行下行转换时，如果转换失败会返回NULL**

  - reinterpret_cast\<type-id\>(expression)作用为：允许将任何指针转换为任何其他指针类型。也允许将任何整数类型转换为任何指针类型及反向转换。**reinterpret_cast是一种高度危险的转换，它仅仅是对二进制的重新解释，是对static_cast的一种补充，可以用于不同指针类型之间的转换**。

  - dynamic_cast\<type\>(expr)，**用于在类的继承层次之间进行类型转换**，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI (运行时类型识别)进行检测，所有只有一部分能成功。**dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。**

- 使用&修饰返回值的函数，表示返回值是对某值的引用，一般可以加上const防止其被修改。

- switch case语句中，switch语句将表达式的值与每个case中的目标值进行了匹配，如果找到了匹配的值，就会执行相应case后的语句，直到遇到**break**推出当前代码块。

  ==如果有几个case是一起的，后面中间的case没有接任何语句，则表示几个case是一样，遇到任一case都只会执行下面的语句，如下：==

  ~~~cpp
  switch (A)
  {
      case 1:
      case 2:
      case 3:
          cout << "case 1 2 3都会执行此语句"<<endl;
          break;
      case 4:
          cout << "case4会执行此语句"<<endl;
          break;
  }
  ~~~

- C++中，array有以下几个概念：

  **物理长度**：是指它在内存中分配的固定大小。在编译时，`std::array` 的大小就已经确定，并在内存中连续地分配了相应的空间。物理长度是 `std::array` 的固定特性，不可更改。

  **逻辑长度**：`std::array` 的逻辑长度指的是实际存储在数组中的元素数量。也就是说，逻辑长度是当前数组中有效元素的个数。逻辑长度可以随着程序的执行而改变，通过修改数组中的元素或使用相关的函数和操作来管理。

- C++类的static的常用用法：

  - 用于在外部构造单例模式，C++里面的instance()单例模式单例对象的理解：

  ~~~cpp
  class PLMDbDatabase
  {
  public:
      /*获取PLMDbDatabase的一个单例对象*/
      static PLMDbDatabase* instance();
  }
  ~~~

  单例模式是通过一个静态成员方法和一个保护下的构造函数配合完成的，只有这个静态方法可以调用构造函数构造该对象，然而该方法确保了该对象只被构造一次；

  - 用于维护类的全局描述符指针，将类的gpDesc成员变量设置为一个static指针，只调用rxInit方法去赋值一次，将其赋值为new出来的RxClass类；然后结束时调用unrxInit方法将其释放，完美维护了描述类的生命周期和描述的稳定性

- C++只有使用static声明静态成员函数才可以直接用“ `类::函数名`”调用，无需实例化，其他是需要实例化后调用的。

  - **1.类的static成员属于类本身，在类加载时就会分配内存，可以通过类名::直接访问；非static成员属于类的对象，即在创建实例对象时才会得到内存分配，然后通过对象调用**
  - **2.正因为static函数属于类，而不是对象，所以static函数压根就没有this指针这个东西，因此也顺理成章的无法直接访问类的非static成员（函数和变量）。但可以通过对象来访问非static成员（经典应用场景：单例模式）**
  - **3.static成员函数的地址可用普通函数指针存储，而非static成员函数的地址则需要使用类的成员函数指针来存储。**

- C++中map删除键值对的方法：

  map类模板提供了**==erase()和clear()==**两种成员方法，可以用来删除容器中存储的键值对。

  - 其中erase()有3种适用于不同实际场景需要的语法格式，这也意味着erase()有3中用法，如下：

    - 可以根据目标键值对位于map容器中的位置，实现删除该键值对的目的。

      > iterator erase(const_iterator position); 
      >
      > // position为迭代器，指向要删除的键值对，同时该方法会返回一个iterator迭代器，其指向的是==删除键值对之后的那个键值对==

    - 除了向 erase() 传入目标键值对位于 map 容器中的位置外，还可以**传入目标键值对的键**，该方法会自行根据指定的键找到目标键值对，并将其删除

      > size_type erase(const key_type& k); 
      >
      > // 参数k为要删除键值对的键，该方法返回值为成功删除的键值对的个数。

    - 使用erase()方法也可以删除指定区域内的所有键值对

      > iterator erase(const_iterator first, const_iterator last); 
      >
      > // 参数first和erase都是迭代器，他们的组合[first, last)表示map容器中的某个范围，该方法会删除此范围内的所有键值对，并返回一个迭代器，指向删除范围后的第一个键值对。

  - clear()方法删除map容器中存储的所有键值对

    > void clear()
    >
    > // 该方法不需要传入任何参数，也不需要接受任何返回值i。

- C++11变长参数模板

  模板与显式的函数参数重载一样，都是一种重载方法

  C++11增加了如下变长参数模板语法

  ~~~cpp
  template<typename... Argv>
  ~~~

  使用三个点“…”来表示不定参数, “Argv”表示参数集合的类型，不同的参数所组成的集合的类型是不一样的。我们把可变的参数集合看成是一种类型而不是多个独立的参数，它在本质上和单个参数是一样的。使用变长参数模板的函数原型如下：

  ~~~cpp
  void func(Argv... argv);
  ~~~

  这里用了“…”表示变长参数列表，而 argv 就是传递过来的参数列表集合。函数里用了“sizeof…(Argv)”获取传递的函数参数个数，同样的用了“…”对 sizeof 的语义进行了扩展。后面还能看到更多的“…”语义扩展，就不重复说了。

- C++在头文件中使用class前置声明，这是因为在该头文件中需要定义该类型的对象/指针作为成员变量。一般情况下，我们会使用include包含该类的头文件，但当项目中的头文件较多，且相互包含的头文件较多时，会减慢程序的编译速度。**因此可以使用另一种方式——class前置声明，既能达到这个效果，又能节省编译时间`class B`， 这样只是声明存在这么一个类，但是通过这种声明无法获得关于此类的任何信息，而在cpp实现需要用到时，我们再包含该文件**

  ==注意C++中类分为声明、定义和实例化，如果只是简单的对类进行声明而未定义成为不完全类，不完全类只能用于定义指针、引用和范围类型，不能定义对象==

- 父命名空间里的东西对于子命名空间都是可见的，另外，一个命名空间也可以在不止一处添加新的变量或类型，在其他位置添加了的变量或类型，在一个新的位置是可以直接使用的，如下：

  ~~~cpp
  namespace ZSoft{
      class A
      {
          // 类定义；
      }
  } //此时在ZSoft内定义了一个类型A
  
  // 此时在文件的另一处存在如下代码
  namespace ZSoft{
   namespace BIM_NAMESPACE_NAME{
       A a; // 在定义ZSoft子空间时可以直接使用ZSoft中定义过的类型
   }
  }
  ~~~

- C++的枚举

  C++的枚举类型包含两种：**限定作用域枚举类型**和不限定作用域枚举类型

  定义限定作用域枚举类型的一般形式是使用**enum class关键字**

  ~~~cpp
  enum class open_modes
  {
      input,
      output,
      append
  };
  ~~~

  - **访问限定作用域枚举类型需要遵循常规的作用域准则，成员在枚举类的作用域外是不可访问的。**

    ~~~cpp
    enum class peppers
    {
        red,
        yellow,
        green
    };
    peppers p = green; // 错误，没有使用作用域访问
    peppers p2 = peppers::red; // 正确，遵循作用域准则
    ~~~

  - **限定作用域枚举类可以解决在同个作用域内，枚举类型的成员不能重名的问题。**

    对于代码规模较大的软件工程，按照模块分配给不同的开发人员开发，不同开发人员可能定义多个枚举类型，不同模块集成到一个工程可能出现同名的枚举成员，按照不限定作用域枚举类型定义会导致编译失败，从而增加代码集成工作量。而使用枚举类进行定义，不同枚举类即使重定义枚举成员也没影响。

  - **枚举类变量必须使用枚举类成员进行初始化或赋值，不能使用整数常量直接初始化或赋值**

    ~~~cpp
    // Color是一个枚举类
    int main()
    {
        Color color1 = Color::Blue; // 正确
        Color color2 = 2; // 错误，类型不匹配，编译报错
        Color color3 = static_cast<Color>(10); // 正确，但没意义
    }
    ~~~

  - **C++编译器不会将枚举类变量默认转换为整数类型，但是我们可以使用强制类型转换将枚举类型变量显式转换为整数类型**

    ~~~cpp
    int main()
    {
        Color color1 = Color::Blue;
        unsigned int color_val1 = color1; // 错误，枚举类变量无法直接隐式转换为整数
        unsigned int color_val2 = static_cast<unsigned int>(color1); // 正确，使用C++强制类型进行显式转换
    }
    ~~~

- 使用static修改的静态成员函数不能用const的原因：一个静态成员函数访问的值是其参数、静态数据成员和全局变量，==而这些数据都不是对象状态的一部分==。而==对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员==。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了。

- 在C++中，enum a:b{}的用法，a是枚举名称，而b是该枚举类型的基础类型。基础类型b可以是整数类型（如 `int`、`char`、`unsigned int` 等），用于指定枚举类型 `a` 的底层存储类型。如果不显式指定基础类型，默认情况下使用 `int` 作为基础类型。

- 注意在进行a=b赋值操作时，一般是赋值，如果需要附引用，需要在声明a时即声明引用并初始化，不然即使b是某个参数的引用，**但是到a这儿，也只是值了**。

- C++重载负号表达式如下：operator -()

- C++类中只声明不定义，那么只要你不使用声明的函数，那么就不会有问题

- C++报错，显示函数...无法访问，那么应该是访问权限不够，比如从外部访问了provate成员   

- a\==b\==c的意思是:先看a与b是否相等,相等为1,不等为0,然后再看这个结果(1或者0)与c是否相等,相等为1,不等为0.

  而**a\==b&&a\==c**就是要求a和bc都相等整个表达式才能为真, 也就是说C++不支持形如a<b<c的比较

- 写类的静态成员方法时，只有声明需要加static，在定义时不用加static。

- 报错：非静态成员引用必须与特定对象相对，这是因为静态函数成员放在全局区，一经声明即分配空间，不需要对象实例化即可访问，而实例成员则需要对象实例化访问，需要分配空间，因此不能再静态成员函数里直接使用实例成员函数、

- 在C++ 中，枚举类（enum class）可以指定枚举成员的默认值。 **如果未为枚举类的成员指定任何值，则其默认值是0**。 如果您希望将默认值设置为不同的值，可以在枚举成员的名称后面使用赋值符号来指定一个值。

- C++ Primer中有如下描述：友元关系不能被继承，**基类的友元对派生类没有特殊的访问权限**。

- **当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的非公有成员。**比如

  ~~~cpp
  class A
  {
   private:
      friend class B;
      void setClass();
  }
  class B
  {
      void setAClass()
      {
          A a;
          a.setClass();
      }
  }  // 可以在B的成员函数内通过A去调用他的私有方法
  ~~~

  

- **在C++中，友元关系是单向的，即如果类A是类B的友元，那么类B可以访问类A的私有成员和保护成员。然而，继承关系不会传递友元关系。所以，如果类A声明类B为友元类，那么类B可以访问类A的私有成员和保护成员。但是，如果类B派生了类C，类C不会自动继承类B与类A之间的友元关系。因此，类C不能直接访问类A中的保护成员变量。如果类C需要访问类A中的保护成员，可以通过类B提供的接口或者方法来间接访问。**

- C++类在实例化之后，其对象访问不了protected和private对象，在类外只能访问public对象，即使是类的实例化对象。

- **C++的隐式或显式转换**：C++的类型转换是通过在类中设置**转换函数作为成员函数**来实现的。C++中的转换函数是一种特殊的成员函数，用于将一个对象转换为另一种类型，转换函数以特殊的语法进行声明，并可以在特定的上下文中进行调用（隐式或者通过static_cast<类型>显式调用）。

  - **==转换函数声明==**：转换函数以类的成员函数形式声明，并使用**`operator`关键字后面跟隐式转换的目标类型作为函数的返回类型**。没有返回值的转换函数使用`void`作为返回类型 |==即转换函数不用写返回类型。==。比如：

    ~~~cpp
    class MyClass{
        public:
        operator int() const; // 转换为int类型
        operator double(); // 转换为double类型
        operator bool() const; //转换为bool类型
    }
    ~~~

  - **==调用转换函数：==**转换函数可以通过隐式或显式调用来触发转换。隐式调用是在需要转换的上下文中自动进行的，而显式调用则是通过在转换函数前使用转换类型进行的。例如：

    ~~~cpp
    MyClass obj;
    int num = obj;             // 隐式调用，将obj转换为int类型
    double dbl = obj.operator double();  // 显式调用，将obj转换为double类型
    bool flag = static_cast<bool>(obj);  // 显式调用，将obj转换为bool类型
    ~~~

  - 转换函数的使用限制：转换函数有一些使用限制，包括但不限于以下内容：
    - 转换函数不能有返回类型为引用类型。
    - 转换函数不能有参数。
    - 转换函数不能是虚函数（除非它们是纯虚函数）。
    - 转换函数不能被继承。

- **在C++中，纯虚函数（Pure Virtual Function）是在基类中声明的虚函数，但没有为其提供具体的实现。纯虚函数用于定义接口，并要求派生类必须实现这个函数。**

  纯虚函数的声明使用以下语法：

  ```cpp
  cppCopy code
  virtual void functionName() = 0;
  ```

  注意到纯虚函数在函数声明的末尾使用`= 0`来表示。这告诉编译器这个函数是一个纯虚函数，没有提供具体的实现。

  纯虚函数的主要目的是定义基类的接口，强制派生类提供对该接口的实现。派生类必须重写基类中的纯虚函数，否则派生类也将成为抽象类。

  抽象类是包含至少一个纯虚函数的类，它们不能被直接实例化。只有派生类实现了纯虚函数后，才能创建其对象。

- C++类中成员变量的初始化有两种方式：构造函数**初始化列表**和构造函数体内**赋值**。**类中const常量，必须在初始化列表中初始，不能使用赋值的方式初始化**。另外，成员变量也可以执行默认初始化，需要注意的是，成员变量的默认初始化仅在以下情况下发生：

  1. 在类的定义中直接初始化成员变量，例如上述示例。
  2. 对象是静态存储期的类成员变量。

  ==**从 C++11 开始，C++ 支持在类的定义中进行成员变量的默认初始化。这种方式被称为成员变量的非静态数据成员初始值设定。**==

- **c++ std中set与unordered_set区别和map与unordered_map区别类似：**

  set基于红黑树实现，红黑树具有自动排序的功能，因此map内部所有的数据，在任何时候，都是有序的。

  unordered_set基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。

- **虚函数不能是静态(static)的**，因为静态函数是类的静态成员，不属于任何一个特定的对象，因此无法被继承和覆盖。 而虚函数则是用于实现运行时多态的，是基于对象的动态绑定机制，它的具体实现与对象的类型相关，因此必须是非静态成员函数。

- C++的`std::unordered_map`在索引不存在的键时会得到一个默认构造的值。对于`bool`类型，默认构造的值是`false`。对于`int`类型，是0.；**对于自定义类型时，例如自定义的类或结构体`std::unordered_map`在索引不存在的键时会得到一个默认构造的值。**具体来说，会调用自定义类型的默认构造函数来创建默认值。如果值是一个复合结构体比如std::pair（int, string）会默认构造一个pair里面first是int的默认构造0，second是string的默认构造空字符串。

- 对于unordered_map，map这些，不要用const auto&, 因为使用它必须允许修改，不能const。

- C++模板函数以关键字template起头，后接模板形参类型。函数模板中的参数和返回值都可以是模板类型参数。**编译器必须通过调用函数模板的实参来推断模板类型参数的具体类型。**但是，当函数模板的返回值是模板类型参数时，编译器无法通过函数调用来推断返回值的具体类型。此时，在调用函数时必须提供一个显式模板实参（explicit template argument）。==因此，调用模板函数时，显式模板实参的提供不是必须的，在返回值不为模板类型参数时，编译器可以通过入参来推断模板类型参数的具体类型==

- **==C++中的extern关键字用法：==**

  extern是c++引入的一个关键字，它可以应用于一个**全局变量，函数或模板声明**，说明该符号具有外部链接*(external linkage)*属性。也就是说，这个符号在别处定义。一般而言，C++全局变量的作用范围仅限于当前的文件，但同时C++也支持分离式编译，允许将程序分割为若干个文件被独立编译。于是就需要在文件间共享数据，这里extern就发挥了作用。

  > 变量的声明指 向程序表明变量的类型和名字，而变量的定义 指申请存储空间（实例化需要定义，而实例化需要申请空间存储），并将其与变量名关联。一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明。**在程序中变量可以声明多次，但只能定义一次，一般而言，定义就是声明。**但是C++中由于extern的缘故，变量的声明和定义是可以分开的，**凡是没有带extern的声明也都是定义。**
  >
  > - 如果这样函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义。
  >
  > - 如果在函数定义的地方带有关键字extern，表示该函数会提供给外部文件使用，其实有些编译器是默认每个函数都是extern类型的，反之是static类型

  extern "C" 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。
   被extern "C"限定的函数或变量是extern类型的；
   **1、extern关键字**
   extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
   通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在**链接阶段**中从模块A编译生成的目标代码中找到此函数。

- 如果在 `new A` 后面不加括号，即 `new A` 后面没有调用构造函数的参数列表，**那么默认会调用 `A` 类的默认构造函数进行对象的初始化***。

- 在C++中，可以使用`typedef`关键字为函数指针类型定义别名，其语法如下

  ~~~cpp
  typedef <返回类型>（*<函数指针别名>）（<参数类型>）;
  ~~~

  指明返回类型以及参数类型，中间即为一个泛性的函数名，根据需要使用\*声明指针或非指针

- c++自定义排序比较函数们需要接受两个参数，**两个参数在实际应用中是按顺序传进去的**，因此返回一个布尔值后，return a<b则是从小到大，return a>b则是从大到小

- C++中比较运算符优先级高于逻辑运算符，但逻辑非或按位取反运算符`！`优先级高于比较运算符和逻辑与/或运算符

  ~~~
  a == 1 && b== 2 与 (a == 1) && (b == 2)等同
  ~~~

- std::get<0>(A)的用法是一个元组访问的用法，表示访问元组A中的第一个元素

- ~~~ 
  std::shared_ptr<PCDbRouteElement> A = std::make_shared<PCDbRouteElement>()
  是创建一个名为A的智能指针对象，其中std::make_shared<PCDbRouteElement>是创建一个RouteElement类型的对象，并返回一个只能指针
  ~~~

- 静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，**在创建第一个对象时，所有的静态数据都会被初始化为零**。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 **::** 来重新声明静态变量从而对它进行初始化

- 联合体和结构体的区别：

  **联合体**

  用途：使几个不同类型的变量共占一段内存（相互覆盖）

  **结构体**

  用途：把不同类型的数据组合成一个整体-------自定义数据类型

  ==当一个联合被说明时，编译程序自动地产生一个变量，其长度为联合中最大的变量长度==

  > 结构体变量所占内存长度是各成员占的内存长度的总和。
  >
  > 共同体变量所占内存长度是各最长的成员占的内存长度。
  >
  > 共同体每次只能存放哪个的一种！！
  >
  > 共同体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用！

  联合体可用于同类型作用对象不同的类型抽象

  > union StyleInfo
  >
  > {
  >
  > GraphicsLineType lineType;
  >
  > GraphicsLineWeight::PlotType plotType;
  >
  > GraphicsHatchType hatchType;
  >
  > }

- 在C++中，将字符串前面使用L前缀，比如L"abc"，表示创建一个宽字符字符串字面量，指示该字符串应该被解释为宽字符（wchar_t）的序列，而不是窄字符（char）。宽字符字符串通常用于处理宽字符编码，如Unicode，其中每个字符可能占用多个字节。通过使用宽字符字符串，您可以存储和操作需要多个字节来表示的字符，例如非ASCII字符或来自不同书写系统的字符。

- 在 C++11 及以后的标准中，派生类的构造函数可以使用 `default` 关键字表示使用默认构造函数。该默认构造函数会隐式的调用基类的构造函数

- 在进行派生类的构造时，**需要先调用基类的构造函数**，是因为派生类继承了基类的成员变量和成员函数，而在创建派生类的对象时，**需要==确保基类的数据成员得到正确初始化==，并执行基类的构造函数来完成基类的初始化工作**。 

- 对于模板函数，模板参数类型 T可以显式的指定，但是在类型较为简单，编译器能自动推断的情况下，可以不指定，由编译器进行类型推断。比如参数为&a（**==即取地址==**）。

- 在C++ 中，可以**使用"==" 操作符来判断两个指针是否相等**。 如果两个指针指向同一个地址，则它们相等；否则它们不相等。

- C++的枚举中不可定义相同的变量但可以定义相同的值。

  ~~~
  
  typedef enum 
  {
  	enumFIRE=0,
  	enumHUMID=1,
  	enumAIRCOND=2,	
  	enumWATER=3,
  	enumAIR=4,//气体 烟感  NSJ
  	enumGATE=5,	
  	enmuLOCAL=6,//本地和远程  NSJ添加
  	enmuBREAKER=7,//断路器反馈 NSJ添加
  	enmuCAN=6,//CAN通讯告警
  }WARN_enum;
  ~~~

- placement new 是什么？

  placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。

  placement new 的语法格式如下：

  new(address) ClassConstruct(...)

  address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(...) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。

  **placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。**

  ~~~c++
  #include <string>
  using namespace std;
  union U {
      string s;
      int n;
  public:
      U() { new(&s) string; }
      ~U() { s.~string(); }
  };
  int main() {
      U u;
      return 0;
  }
  ~~~

- **如果你的抽象类的派生类有任何一个纯虚函数没有实现，那么不管其他做的再多，这个类仍然是一个抽象类。**

  所以用到你定义的子类实例化对象时候，会产生上述的错误。

  好在编译器能够帮助我们，以至于可以及时改正。

  所以，在继承一个类的时候，要确保实现了所有这个基类的纯虚函数。注意不能同时使用 override 和 = 0，如果一个虚基类派生了另外一种虚基类，则在派生类的纯虚函数还是写上virtual和=0。

- const指针是指针变量的值一经初始化，就不可以改变指向，初始化是必要的。其定义形式如下：type *const 指针名称;

　　声明指针时，可以在类型前或后使用关键字const，也可在两个位置都使用。例如，下面都是合法的声明，但是含义大不同：

~~~
const int * pOne;  //指向**整形常量** 的指针，它指向的值不能修改
int * const pTwo;  //指向整形的**常量指针** ，它不能在指向别的变量，但指向（变量）的值可以修改。 
~~~

- C++的unique_ptr：

  unique_ptr是一种定义在\<memory\>中的智能指针(smart pointer)。独享对对象的所有权——两个unique_ptr不能指向同一个对象，也不能进行复制，只能进行移动操作。这样可以防止内存泄漏，当对象被销毁时，他的析构函数会删除关联的原始指针。

  unique_ptr不想shared_ptr一样由标准库函数make_shared创建一个shared_ptr实例，**要想创建一个unique_ptr，需要将new操作符返回的指针传递给unique_ptr的构造函数**

  ~~~c++
  int main()
  {
      unique_ptr<int> pInt(new int(5));
      cout<<*pInt;
  }
  ~~~

- 表达式的副作用的概念一般说计算一个表达式的值需要引用一些变量，在表达式求值过程中，需要提取这些变量的值，但并不改变这些变量的值，这样的表达式称为无副作用的表达式． 

- `explicit`修饰的构造函数不能被隐式调用 禁止类对象之间的隐式转换

- 一旦基类中使用=delete来声明基类的某个成员函数为删除的，那么派生类中的对应函数也会自动地变成删除的。

- 因此`effective c++`建议，一个类一旦确认要被继承就应该在其析构函数前加上关键字`virtual`

- 通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。而再构造时无论是new还是声明，都需要确切知道对象类型，因此构造函数不能是虚函数

- 使用关键词class的*类默认继承*方式和成员默认访问权限是private，使用关键词struct的*类的默认继承*方式和成员默认访问权限是public；

- 当基类和子类中声明的是同名非[虚函数](https://so.csdn.net/so/search?q=虚函数&spm=1001.2101.3001.7020)时，可以看到当子类指针所调用函数只存在于基类中时，调用的是基类的函数，当此时在基类函数中调用与子类函数中的同名函数时，调用的依旧是基类中的函数，这个我的理解就是积累函数中操作的this指针只能调用基类函数．==重载只是给函数名字加了一些修饰，原来的函数还是存在，而this指针只能识别原来的函数==！

- \#的作用是将“#”后面的宏参数进行字符串转换操作，也就是将#后面的参数 两边加上一对双引号，使其成为[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)。

- 和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。

  另外析构函数的执行顺序和构造函数的执行顺序也刚好相反：
  创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数。
  而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。

- C++要从一堆vector或悟空的Array中删除一堆（不连续的）索引，不要边遍历便删除，最好还是直接开一个新的Array，把满足要求的再放入新的array中。

- 在参数表最后连续写三个圆点符号，**说明这个函数具有可变数目的参数**。 凡参数表具有这种形式（最后写三个圆点），就表示定义的是一个变参数函数。

- template< class F, class... Args >是函数模板的声明，定义里两个模板参数：F表示函数对象(或者函数指针)的类型；Args...表示零个或多个其他参数的类型，允许模板接收可变数量的参数。

- **std::bind绑定用法**

  ~~~c++
  template< class F, class... Args >
  /*unspecified*/ bind( F&& f, Args&&... args );
  ~~~

  

  - std::bind返回一个基于f的函数对象，其参数被绑定到args上，**f的参数要么被绑定到值，要么被绑定到placeholder(占位符，如_1, _2, ..., _n)

  - std::bind主要有两个作用：**将可调用对象和其参数绑定成一个仿函数；只绑定部分参数，减少可调用对象传入的参数。**

  - 绑定普通函数：

    ~~~cpp
    
    double callableFunc (double x, double y) {return x/y;}
    auto NewCallable = std::bind (callableFunc, std::placeholders::_1,2);  
    std::cout << NewCallable (10) << '\n';  
    ~~~

  - 绑定成员函数**==注意绑定自己的成员函数时，成员函数有一个隐式的形参this指针！==**

    ~~~cpp
    
    class Base
    {
    public:
        void display_sum(int a1, int a2)
        {
            std::cout << a1 + a2 << '\n';
        }
     
        int m_data = 30;
    };
    int main() 
    {
        Base base;
        auto newiFunc = std::bind(&Base::display_sum, &base, 100, std::placeholders::_1);
        f(20); // should out put 120. 
    // bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址
     
    ~~~


- C++自定义排序

  sort函数有三个参数

  sort(first,last,cmp);

  其中，**first**是元素的**起始地址**，**last**是**结束地址**，**cmp**是**排序的方式**。对**[first****，last)（一定要注意这里的区间是左闭又开）**区间内数据根据cmp的方式进行排序。也可以不写第三个参数，此时按默认排序，从小到大进行排序**。

  默认是升序排列，cmp方法也是替代<符号的结果，即认为参数a比参数b小时返回true

  ~~~c++
  (1)自定义比较函数cmp
  
  比如：
  
  bool cmp(int a,int b)
  
  {
  return b<a;
  }
  
  sort(a,a+n,cmp);
  
  **传入的参数类型和需要排序的数据类型一致**，如果认为第一个参数比第二个小，也就是第一个参数需要排在第二个参数前面时返回true，反之返回 false。系统默认a<b时返回true，于是从小到大排。而上面的例子是当b小于a时，认为a小于b。所以排序的结果就是将元素按从大到小的顺序排序
  ~~~

- 模板类list是一个容器，list是由双向链表来实现的，每个节点存储1个元素。list支持**前后**两种移动方向。注意list不支持随机存取，不提供下标操作符和at()函数。list也提供了特殊成员函数，专门用于移动元素。

- 在类的继承中，类的私有成员在派生类中是“不可见“的，这种”不可见“是指在**派生类的成员函数**中，或者通过派生类的对象（指针，引用）不能直接访问它们。但是，不能直接访问并不代表不能访问。在派生类还是能够通过调用基类的共有函数的方式来间接地访问基类的私有成员，包括私有成员变量和私有成员函数。

  派生后，派生类可以访问基类的成员，如果重写了基类的某个方法，基类的方法也不是说不能访问了，只是不加作用域的情况下，默认会访问到派生类的重写方法(编译器会给派生类的重写方法的方法名做一系列前缀标志)，**而在派生类的成员方法下是访问不到基类的私有成员和方法的**

- 在使用基类指针，子类对象，调用基类的非虚函数（子类重载同名函数）时，只能调用到基类的对应方法。

  **这是因为，c++本身是一个强类型语言，多态机制本质上是在构造基类时，如果有虚函数则同时构造了一个虚表，调用虚函数时会在虚表寻址，而如果没有虚函数，基类指针不认识子类重载的函数（对于编译器而言这是两个完全不同的方法）**

  **虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。
  虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。**

  **虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。**

  **现在，我们声明一个类A的指针p来指向对象`bObject`。虽然`p`是基类的指针只能指向基类的部分，但是虚表指针亦属于基类部分，所以`p`可以访问到对象`bObject`的虚表指针。`bObject`的虚表指针指向类B的虚表，所以`p`可以访问到B vtbl。**==基类指针只能指向基类的部分，虚表指针的存在能让基类指针也能指向派生类的一些方法。==

  ==**在内存中，一个**基类**类型的**指针**是覆盖N个单位长度的内存空间。 当其**指向**派生**类**的时候，由于派生**类**元素在内存中堆放是：前N个是**基类**的元素，N之后的是派生**类**的元素。 于是**基类**的**指针**就可以访问到**基类**也有的元素了，但是此时无法访问到派生**类**（就是N之后）的元素。**==

  **对于类A这种简单的类，其对象内存布局的最开始四个字节就是一个虚函数表指针（32位编译器）**

- **在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化。**

  - 首先说下聚合类型可以进行直接列表初始化

    聚合类型判断如下：

    - 没有用户声明的构造函数
    - 没有用户提供的构造函数(允许显示预置或弃置的构造函数)
    - **没有私有或保护的非静态数据成员**
    - 没有基类
    - 没有虚函数
    - 没有{}和=直接初始化的非静态数据成员
    - 没有默认成员初始化器（就是没有使用构造函数初始化列表方式初始化的成员）

  - 上面列举了一些不是聚合类的例子，==对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值==；==对于非聚合类型，需要先自定义一个对应的构造函数，此时列表初始化将调用相应的构造函数==。

  - 优点：

    - 方便，且基本上可以替代括号初始化

    - 可以使用初始化列表接受任意长度

    - 可以防止类型窄化，避免精度丢失的隐式类型转换

- 在构造一个list类型的对象时，比如vector、array等，3.要想直接构造一个只有一个元素的list类型对象，可以在构造时指定初始逻辑长度（逻辑长度是指在当前业务逻辑下的实际业务可控长度，物理长度是指在内存中的预留空间），并指定在当前长度下的元素初始值。

- **静态局部变量具有以下特点：**该变量在全局区分配内存；静态局部变量在程序执行到该对象的声明处首次初始化，即便以后的函数调用也不再进行初始化；它将始终驻留在全局数据区，直到程序运行结束。但其作用域是局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

  另外，static局部变量具有**记忆性**，与生存周期的**全局性**，见如下例

  ```cpp
  #include<iostream>
  using namespace std;
  
  void static_localVar()
  {
      static int a = 0; //运行到此时初始化，下次运行是不需要再初始化，因为一直保存在全局区
      cout << "a=" << a << endl;
      ++a;
  }
  
  int main()
  {
      static_localVar();
      static_localVar();
      static_localVar();
      //cout << a << endl;  //error,因为已经离开a的作用域
  
      return 0;
  }
  ```

- **类的前置声明**只能作为指针或引用，不能定义类的对象，比如定义了class A；如果没有定义A的具体内容，则在该文件中只能以A* p的形式使用，此时编译器知道分配一个指针地址给这个变量就行，但如果使用A p会报错，因为编译器并不知道该给p分配多少内存。

  **何时使用前置声明和#include**

  ~~~cpp
  // 需要获得某个类型的定义才使用头文件
  如下，哪些需要C的定义：
  
  一、A继承至C
  二、A有一个类型为C的成员变量
  三、A有一个类型为C的指针的成员变量
  四、A有一个类型为C的引用的成员变量
  五、A有一个类型为std::list的成员变量
  六、A有一个函数，它的签名中参数和返回值都是类型C
  七、A有一个函数，它的签名中参数和返回值都是类型C，它调用了C的某个函数，代码在A的头文件中
  八、A有一个函数，它的签名中参数和返回值都是类型C(包括类型C本身，C的引用类型和C的指针类型)，并且它会调用另外一个使用C的函数，代码直接写在A的头文件中
  九、C和A在同一个名字空间里面
  十、C和A在不同的名字空间里面
   
  情况一：必须要知道C的定义，因为A作为子类，必须要知道C的内容，才能继承
  情况二：必须要知道C的定义，因为需要根据C来确定A的大小，一般用Pimpl模式 改善。
  情况三和情况四：不需要知道C的定义，只需要前置声明就可以了。引用在物理上（即在内存中）也是一个指针，效果和指针一样。即便没有C的定义，A也不会有任何问题。
  情况五：不需要知道C的定义，有可能老式的编译器需要。标准库里面的容器（如：list、vector、map），在包括一个list，vector，map类型的成员变量的时候，都不需要C的定义。因为它们内部其实也是使用C的指针作为成员变量，它们的大小一开始就是固定的了，不会根据模版参数的不同而改变。
  情况六：不需要知道C的定义
  情况七：必须要知道C的定义，需要知道调用函数的签名。
  
  情况八：对于引用和指针情况一样
  例如：
  类C中有：C& CdoSomething(C&);
  类A中有：C& AdoSomething (C& c) { return CdoSomething (c);};
  以上情况，不需要知道C的定义，但是对上面的函数任意一个C&换成C，比如像下面的几种示例：
  
  类C中有：C& CdoSomething (C&);
  
  类A中有：C& AdoSomething (C c) {return CdoSomething (c);};
  
  类C中有：C& CdoSomething (C);
  
  类A中有：C& AdoSomething (C& c) {return CdoSomething (c);};
  
  类C中有：C CdoSomething (C&);
  
  类A中有：C& AdoSomething (C& c) {return CdoSomething (c);};
  
  类C中有：C& CdoSomething (C&);
  
  类A中有：C AdoSomething (C& c) {return CdoSomething (c);};
  
  那么就必须要C的定义。无论哪一种，其实都隐式包含了一个拷贝构造函数的调用，比如1中参数c由拷贝构造函数生成，3中CdoSomething的返回值是一个由拷贝构造函数生成的匿名对象。因为我们调用了C的拷贝构造函数，所以以上无论那种情形都需要知道C的定义。
  ~~~

  

- 在std里，判断两个指针是否相等是通过判断两个指针里的内容（即指针指向的地址）是否相等来判断，两个指向相同地址的指针使用==比较符返回会为true

- 在使用=delete运算符删除C++类的拷贝构造等方法时，首先声明了该方法，因此此时编译器不会合成默认构造函数，需要显式声明和定义（比如=default）

- insert参数为pair类型，作为一个包含key&value的对象直接插入. emplace可以将key和value的构造参数直接传入，在其内部构造key和value，节省了先构造key&value再复制插入的时间和资源，比insert更加有效率。

- ==STL的unordered_set是一个无序容器，它可以存储一组唯一的元素，而且不保证元素的顺序。unordered_set的底层实现是哈希表，因此插入、删除和查找的时间复杂度平均为O(1)==。

- 使用erases删除unordered_map和unordered_set里的元素时，会返回一个size_type类型的数，表示成功删除了多少个元素，如果传入的元素在set/map中没有，则会返回0.

- 使用static_cast不能用于指向基类对象的基类指针转换向子类指针，转换后编译不会报错，且指针也会有值，后续可能发生严重错误；

  使用dynamic_cast可以用于指向基类对象的基类指针转换向子类指针

- 注意unordered_map的[]操作符返回的是值的引用，可以直接进行操作修改值

- 对于一个以非内建类型的unorderedmap，需要自己写哈希函数和等价函数，写一个callable对象就行，对于一个结构体，写operator()方法，例子如下

  ~~~cpp
  struct hashForObjectIdArr
  {
  	size_t operator()(const Array<ObjectId>& objIdArr) const
  	{
  	std::size_t seed = objIdArr.length();
  	for (const auto objId : objIdArr)
  	{
  	const Stub* pStub = objId;
  	const auto objHash = size_t(pStuv);
  	seed ^= objHash + 0x9e3779b9 + seed<<6 + seed>>2
  	}
  	}
  }
  /*
  & （位   “与”）  and
  ^  （位   “异或”）
  |   （位    “或”）   or
  ~  （位   “取反”）
  */
  ~~~


- unordered_map是一种关联式容器，由于它是无序的，所以遍历删除时不能直接使用迭代器。可以使用以下方法进行遍历删除：

  1. 使用迭代器遍历unordered_map，并记录需要删除的项目，最后一次性删除。
  2. 使用C++11提供的erase（）函数的返回值，该函数返回删除元素的下一个位置的迭代器，所以可以直接跳过已删除的元素。

  ```c++
  unordered_map<int, int> myMap;
  for (auto it = myMap.begin(); it != myMap.end();) {
      if (it->second == value) {
          it = myMap.erase(it);
      } else {
          ++it;
      }
  }
  ```

- ==静态类的特点就是全局一份，所以无论是通过静态类的方法改变，还是通过子类的方法改变，都会对其产生调用关系。
  静态类的方法不能通过继承方式实现多态，但子类可以使用同名方法隐藏父类方法。
  子类也可以直接以类名::方法来访问静态基类的方法。==

  父类的静态方法，通过子类的作用域也能访问，但是不能重写或重载；可以写一个同名函数来对父类的静态方法隐藏。（主要表现在rx系统子类没有派生就会生成父类的rxclass描述）


- 顺序表的一般操作函数：

  clear（清除表）、traverse（正序输出）、search（搜索表）、insert（插入）、remove（删除）、inverse（倒序输出）、resize（修改）、visit（查看）。

  traverse函数横渡，正序遍历表里面所有的元素，该函数是一个vector、tree、table等都比较多的函数，可以添加一个回调，和起始点，让起始点元素开始遍历，每次遍历执行回调操作，可以命名为traverse遍历操作函数，

- 在C++ Primer当中提到的64位的int只有long long,但是在实际各种各样的C++编译器当中,64位的int一直有两种标准.一种是long long,还有一种是\_\_int64,非主流的VC甚至还支持_int64

- `long long`最早是C99标准引进的，然而VC6.0推出于1998年，在C99标准之前。所以当时微软就自己搞出来一个变量叫做`__int64`来表示64位整数。win平台下的一些其他IDE如`dev C++ `，`CodeBlocks`等也支持long `long`，因为它们为了和微软的系统兼容，所以也支持`__int64`。所以一个比较简单的区分方法是，判断编译器运行的操作系统是否是windows，如果是`windows`使用`__int64`，否则使用`long long`

- atoi函数和std::stoi函数都可以将数字字符转化为int输出，其不同点在于以下几点：

  出处不同

  - `atoi()`函数是C标准库函数，头文件为`#include<stdlib.h>`。同类型函数还包括`atol()`，`atof()`，`strtol()`，`strtof()`等；
  - `std::stoi()`函数是C++11开始加入的STL标准模版库的函数，头文件为`#include<string>`。同类型函数还有`std::stol()`，`std::stoll()`；

  功能不同

  - ```
    atoi()
    ```

    - 会跳过前面的空白字符（包括空格，tab符号等），直到遇到第一个非空字符，并在遇到下一个非数字字符时结束转换；
    - 转换的内容为正负符号和数字字符；
    - 并且返回值为十进制；

  - ```
    std::stoi()
    ```

    - 会跳过最前面的空白字符（包括空格，tab符号等），直到遇到第一个非空字符，并在遇到下一个非数字字符时结束转换；
    - 转换的内容为正负符号和数字字符；
    - 可以指定开始转换的pos；
    - 可以转换成十进制，八进制和十六进制；

  异常处理不同

  - `atoi()`函数在转换时，如果遇到入参str不能转换或者str为空字符串时，返回值为0，不会抛出异常；
  - `std::stoi()`函数在转换时，如果入参str是字母或者空字符串而无法转换成数字时，会抛出`std::invalid_argument`异常，使用者必须手动处理异常，否则会造成程序crash；

- C++只有数组能以列表初始化的方式进行赋值和初始化，而指针不能。但是数组可以表示为首个元素的地址，因此可以将其赋值给某个指针。总的来说，初始化列表->数组->指针；但是对于字符串，可以看作是一个直接就是初始化后的字符数组（放在常数段，静态存储区），因此可以直接用来初始化常量字符指针const char*

  ~~~c++
  int b[] = { 1, 2, 3 };
  int* a = b;
  // 报错
  //const char* b = {'1', '2', '3'};
  //可以
  const char* c = "123";
  //可以
  char d[] = { '1', '2', '3','3' };
  const char* e = d;
  ~~~


- 拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个**已经存在的实例**。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。**调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符**。

  ~~~cpp
  class Person
  {
  public:
  	Person(){}
  	Person(const Person& p)
  	{
  		cout << "Copy Constructor" << endl;
  	}
  
  	Person& operator=(const Person& p)
  	{
  		cout << "Assign" << endl;
  		return *this;
  	} // 直接返回*this，赋值表达式以等式的左边作为表达式的返回值
  
  private:
  	int age;
  	string name;
  };
  ~~~

- C++中使用联合体时，一般用一个struct包住，结构体内除了放一个union外，额外放一个enum标识当前处于什么数据结构

- **C++占位符**：

  ~~~c++
  格式说明由“％”和格式字符组成，如％d％f等。它的作用是将输出的数据转换为指定的格式输出。格式说明总是由“％”字符开始的。 
  
  格式字符有d,o,x,u,c,s,f,e,g等。 
  如
  
  ％d整型输出，％ld长整型输出，
  
  ％o以八进制数形式输出整数，
  
  ％x以十六进制数形式输出整数，或输出字符串的地址。
  
  ％u以十进制数输出unsigned型数据(无符号数)。注意：%d与%u有无符号的数值范围，也就是极限的值，不然数值打印出来会有误。
  
  ％c用来输出一个字符，
  
  ％s用来输出一个字符串，
  
  ％f用来输出实数，以小数形式输出，默认情况下保留小数点6位。
  
  %.100f用来输出实数，保留小数点100位。
  
  ％e以指数形式输出实数，
  
  ％g根据大小自动选f格式或e格式，且不输出无意义的零。
  ~~~

- C++中string转字符数组，在std标准库提供了.data()和.c_str()方法

  ~~~c++、
  string str="abc"; 
  char *p=str.data(); 
  
  string str="gdfd"; 
  char *p=str.c_str(); 
  ~~~

- 关于编码以及编码转换

  > UTF-8与GBK的区别:
  >
  > GBK就是在保存你的帖子的时候，一个汉字占用两个字节。外国人看会出现乱码，此为我中华为自己汉字编码而形成之解决方案。
  >
  > UTF8就是在保存你的帖子的时候，一个汉字占用3个字节。但是外国人看的话不会乱码，此为西人为了解决多字节字符而形成之解决方案。
  >
  > ASCII(ISO-8859-1)是鼻祖，最简单的方式，字节高位为0。
  > GB2312、GBK、GB18030，这几个是中文编码方式，并向下兼容。GB2312包含7000多个汉字和字符，GBK包含21000多个，GB18030更厉害，到了27000多个。**他们都是用2个字节来表示一个汉字。跟ascii是怎么区分的呢？如果高字节的高位为1（也就是高字节大于127），就表示是汉字，低字节并无明显特征。**
  >
  > UTF－8是Unicode的一种存储、传输方式。它将整个Unicode码表分为3部分。
  > 0000 - 007F 这部分是最初的ascii部分，按原始的存储方式，即0xxxxxxx。
  > 0080 - 07FF 这部分存储为110xxxxx 10xxxxxx。
  > 0800 - FFFF 这部分存储为1110xxxx 10xxxxxx 10xxxxxx。
  > 因此，一个汉字究竟被存储为什么，就需要：先查unicode码表，然后根据在码表的位置进行计算。例如：“电”字，在码表中是3575，计算成utf8就是E794B5，而在GB2312的码表中为B5E7
  > UTF－8的好处：兼容ASCII，存储英文文件都是单字节，文件小。当然，当以存中文为主时就变成了3字节编码了，比GB系列还大！如何标明一个文件是utf8格式呢？这个标记是可选的：EF BB BF。比如，用windows自带的记事本创建一个utf8格式的文件，就会加上这个标记。但是，如果用ultraedit创建utf8文件，并不会加上这个标记。这个标记有个术语，叫做BOM（Byte Order Mark）。不带BOM的utf8文件和GB2312文件怎么区分呢？我也不知道。唯一能想到的办法就是：先用一种试，如果出现乱码，就用另一种再试

- 关于std::wstring_convert的使用:**std::wstring_convert 使用需要指定模板参数，用于描述编码之间的转换方式，**

  > 模板参数有:
  >
  > std::codecvt_utf16<wchar_t>：用于将UTF-16编码的std::wstring类型字符串转换为wchar_t类型的std::wstring类型字符串，或将wchar_t类型的std::wstring类型字符串转换为UTF-16编码的std::wstring类型字符串。
  > std::codecvt_utf8_utf16<wchar_t>：用于将UTF-8编码的std::string类型字符串转换为UTF-16编码的std::wstring类型字符串，或将UTF-16编码的std::wstring类型字符串转换为UTF-8编码的std::string类型字符串。
  > std::codecvt<wchar_t, char, std::mbstate_t>：用于将多字节编码的std::string类型字符串转换为wchar_t类型的std::wstring类型字符串，或将wchar_t类型的std::wstring类型字符串转换为多字节编码的std::string类型字符串。
  > std::codecvt_utf8<char32_t>：用于将UTF-8编码的std::string类型字符串转换为char32_t类型的字符串，或将char32_t类型的字符串转换为UTF-8编码的std::string类型字符串。

  ~~~c++
  举例：字符编码的转换：UTF-8 转 wchar_t
  std::string str = "hello world";  // 源字符串
  std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;  // 创建转换器对象
  std::wstring wstr = converter.from_bytes(str);  // 将源字符串转换为std::wstring类型的字符串
  
  需要注意的是，上面代码中 hello world 编码方式是未知的，这和编译器编码方式有关，在 Windows 操作系统下，Visual Studio 编译器默认使用的编码方式是 GBK，而在 Linux 或者 Mac OS X 下，常见的编译器比如 GCC 和 Clang 默认使用的编码方式是 UTF-8。
  使用 std::codecvt_utf8<wchar_t> 明确指定了要将 std::string 类型的字符串按照 UTF-8 编码方式转换为 std::wstring 类型的字符串，若实际 std::string 不是 UTF-8 编码，则可能出现乱码情况。
  ~~~

- ==为什么需要宽字符类型==

  “你好”对应的Unicode分别为"U+4f60"和"U+597d”，对应的UTF-8编码分别为“0xe4 0xbd 0xa0”和“0xe5 0xa5 0xbd”

  多字节字符串在编译后的可执行文件以UTF-8编码保存，如果当前终端的驱动程序能识别UTF-8编码就能打印汉字，如果当前字符终端的驱动程序不能识别UTF-8就打印不出汉字。

  宽字符串在编译后可执行文件中以Unicode保存，目前宽字符在内存中以Unicode进行保存，但是要write到终端仍然需要以多字节编码输出，这样终端驱动程序才能识别，所以printf在内部把宽字符串转换成多字节字符串，然后write出去。这个转换过程受locale影响，setlocale(LC_ALL, "zh_CN.UTF-8");设置当前进程的LC_ALL为zh_CN.UTF-8，所以printf将Unicode转成多字节的UTF-8编码，然后write到终端设备。如果将setlocale(LC_ALL, "zh_CN.UTF-8");改为setlocale(LC_ALL, en_US.iso88591):打印结果中将不会输出"你好"。

  > 既然提到了Unicode编码，为什么又有UTF-8编码方案呢？其实我们常常混淆了两个概念，即字符代码和字符编码，==字符代码是特定字符在某个字符集中的序号，而字符编码是在传输、存储过程当中用于表示字符的以字节为单位的二进制序列。==ASCII编码系统中，字符代码和字符编码是一致的，比如字符A，在ASCII字符集中的序号，也就是所谓的字符代码是65，存储在磁盘中的二进制比特序列是01000001（0X41，十进制也是65），另外的，如在GB2312编码系统中字符代码和字符编码的值也是一致的，所以无形之中我们就忽略了二者的差异性。而在Unicode标准中，我们目前使用的是UCS-4，即字符集中每一个字符的字符代码都是用4个字节来表示，其中字符代码0~127兼容ASCII字符集，一般的通用汉字的字符代码也都集中在65535之前，使用大于65535的字符代码，即需要超过两个字节来表示的字符代码是比较少的。因此，如果仍然依旧采用字符代码和字符编码相一致的编码方式，那么拉丁字母原本仅需一个字节编码，目前就需要4个字节进行编码，汉字原本仅需两个字节进行编码，目前也需要4个字节进行编码，这对于存储或传输资源而言是很不划算的。因此就需要在字符代码和字符编码间进行再编码，这样就引出了UTF-8、UTF-16等编码方式。

  **换句话说，宽字符编码在内存中以最原始的unicode字符集编码了需要的字符（包括英文、汉字），在将其输出到终端时，可以根据终端的环境变量调用标准库的转换方式将其转换为对应的编码进行输出，这样能够有最高的兼容性。真正需要编码到utf-8或者GBK的一般是需要设备间的传输的时候。**

  **字符代码是在某个字符集中的序号，是十进制映射的结果；字符编码是将该字符以二进制形式存储时的二进制存储方式。**

- >- ==对应不同编码方式与字符对应关系==
  >
  >  不同的字符编码方式会使用不同的方法将字符映射到字节序列。下面是一些常见的字符编码方式及其字节对应关系：
  >
  >  **ASCII 编码**：ASCII（American Standard Code for Information Interchange）是最早的字符编码方式之一，使用一个字节（8位）来表示一个字符。ASCII 编码定义了128个字符，包括英文字母、数字、标点符号和控制字符，其中7位表示字符本身，剩余的一位用作奇偶校验。
  >
  >  **UTF-8 编码**：UTF-8（Unicode Transformation Format - 8-bit）是一种可变长度的 Unicode 编码方式，它使用1到4个字节来表示一个字符。对于英文字母、数字和标点符号等ASCII 字符，UTF-8 使用一个字节表示，而对于其他字符（包括汉字和 Emoji 等），UTF-8 使用多个字节表示。
  >
  >  **UTF-16 编码**：UTF-16（Unicode Transformation Format - 16-bit）是一种固定长度的 Unicode 编码方式，它使用两个字节（16位）来表示一个字符。对于大多数常用字符，UTF-16 使用两个字节表示，而对于一些辅助字符（如表情符号和一些罕见的字符），UTF-16 使用四个字节表示。
  >
  >  **UTF-32 编码**：UTF-32（Unicode Transformation Format - 32-bit）是一种固定长度的 Unicode 编码方式，它使用四个字节（32位）来表示一个字符。UTF-32 对于所有 Unicode 字符都使用相同长度的编码。
  >
  >  这些编码方式中，ASCII 编码是单字节编码，而 UTF-8、UTF-16 和 UTF-32 是==多字节编码，它们在表示字符时会使用不同数量的字节==。
  >
  >- wchar_t的理解
  >
  >  宽字符编码（Wide Character Encoding）通常用于表示较大的字符集，如 Unicode 字符集。在 C/C++ 中，通常使用 `wchar_t` 类型来表示宽字符。下面是几种常见的宽字符编码方式及其字节对应关系：
  >
  >  1. **UTF-16 编码**：UTF-16 是一种固定长度的宽字符编码方式，使用两个字节（16位）来表示一个字符。UTF-16 编码通常用于 Windows 系统中。在 UTF-16 中，大多数常用字符使用两个字节表示，而一些辅助字符（如 Emoji）需要使用四个字节表示。
  >  2. **UTF-32 编码**：UTF-32 是一种固定长度的宽字符编码方式，使用四个字节（32位）来表示一个字符。UTF-32 编码对于所有 Unicode 字符都使用相同长度的编码，因此它在表示字符时非常简单，但是会消耗更多的存储空间。
  >  3. **UCS-2 编码**：UCS-2 是一种固定长度的宽字符编码方式，使用两个字节（16位）来表示一个字符。它类似于 UTF-16，但不支持辅助字符，因此只能表示 Unicode 的基本多语言平面（BMP）中的字符。
  >
  >  **wchar_t的确切大小和编码方式是由目标平台和编译器决定的，因此在编写可移植的代码时，最好避免对 `wchar_t` 的编码方式做出假设，并尽可能使用标准库中提供的多字节编码函数（如 `std::wstring`）来处理宽字符数据。**
  >
  >- 尽管utf-8是多字节编码中最为灵活和节省内存的编码方式（都能表达unicode字符全集），但是wchar_t使用固定长度编码在效率上更有优势：
  >
  >  1. **访问速度**：由于宽字符编码使用固定长度的编码单元来表示字符，因此在某些情况下，它可能会比 UTF-8 更快地访问单个字符。这对于需要频繁访问字符的应用程序来说可能更为重要。
  >  2. **字符处理**：在某些特定的字符处理操作中，宽字符编码可能会比 UTF-8 更有效率。例如，字符串拼接和搜索操作可能会更快，因为宽字符编码中的每个字符都有固定的大小。
  >  3. **内存占用**：尽管宽字符编码在存储时通常需要更多的空间，但在某些情况下，它可能会在内存使用方面更为高效。这是因为宽字符编码中的每个字符都具有固定的大小，使得在内存中更易于管理。
  >
  >- GBK和GB18030的优势与定义
  >
  >  他们都是在中国国家标准GB 2312的基础上扩展的，通过存储和映射关系的优化，这些方式在中文字符的表示上更有效率和空间友好，但是相比于utf_8牺牲了通用性和兼容性。

- 由于 `wchar_t` 的具体编码方式取决于编译器和目标平台，因此在编写可移植的代码时，最好避免对 `wchar_t` 的编码方式做出假设，并尽可能使用标准库中提供的多字节编码函数（如 `std::wstring`）来处理宽字符数据。


- 关于C++的std::sort方法

  ~~~cpp
  需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：
  容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持。
  如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；
  sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。
      
  //对 [first, last) 区域内的元素做默认的升序排序
  void sort (RandomAccessIterator first, RandomAccessIterator last);
  //按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
  void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
  ~~~

  另外在第 2 种格式中，cmp 可以是 C++ STL 标准库提供的排序规则（==比如 std::greater\<T\>(类似大于号重载，true放前面，降序)，比如std::less\<T\>(类似小于号重载，true放前面，升序)==），也可以是自定义的排序规则。
  关于如何自定义一个排序规则，除了《C++ STL关联式容器自定义排序规则》一节介绍的 2 种方式外，还可以直接定义一个具有 2 个参数并返回 bool 类型值的函数作为排序规则。

- 注意C++中的operator()是**函数调用操作符**!STL中的各种functor就是重载它实现的.重载该操作符后，结构体可以隐式的变为一个callable对象，可以被如A（5）式调用(==不用A()(5)==)。具体可看<a href= "#函数调用操作符">函数调用操作符</a>


- ANSIC标准定义了以下5种可供C语言使用的预定义宏： 
  \_\_LINE\_\_ 在源代码中插入当前源代码行号 
  \_\_FILE\_\_ 在源代码中插入当前源代码文件名 
  \_\_DATE\_\_ 在源代码中插入当前编译日期〔注意和当前系统日期区别开来〕 
  \_\_TIME\_\_ 在源代码中插入当前编译时间〔注意和当前系统时间区别开来〕 
  \_\_STDC\_\_ 当要求程序严格遵循ANSIC标准时该标识符被赋值为1。 

- ==深入理解计算机系统：bss段、data段、text段、堆(heap)和栈(stack)==

  > bss段：属于静态内存分配
  >
  > **bss段**通常指用来存放程序中**未初始化的全局变量或静态变量**的一块内存区域，block start by symbol的简称。
  >
  > data段：属于静态内存分配
  >
  > **数据段**通常指用来存放**已初始化的全局变量或静态变量**的一块内存区域。
  >
  > text段：代码段，这部分区域大小在程序运行前就确定，且内存区域通常属于只读
  >
  > **代码段**一般用来存放程序执行代码的一块内存区域，也有可能包含一些只读的常数变量
  >
  > 堆：属于动态内存分配
  >
  > 堆是用于存放进程运行中被动态分配的内存段，可动态扩张或缩减
  >
  > 栈：用户存放程序临时创建的局部变量

- C++异常处理：

  异常提供了一个转移程序控制权的方式：涉及三个关键字：try、catch、throw

  >throw: 当问题出现时，程序会抛出一个异常。这是通过throw关键字完成的。
  >
  >catch：在您想要处理问题的地方，通过异常处理程序捕获异常。
  >
  >try：try块中的代码标识将被激活的特定异常，后面通常跟着一个或多个catch块。try中的代码称为保护代码

  ~~~cpp
  #include <iostream>
  using namespace std;
   
  double division(int a, int b)
  {
     if( b == 0 )
     {
        throw "Division by zero condition!";
     }
     return (a/b);
  }
   
  int main ()
  {
     int x = 50;
     int y = 0;
     double z = 0;
   
     try {
       z = division(x, y);
       cout << z << endl;
     }catch (const char* msg) {
       cerr << msg << endl;
     }
   
     return 0;
  }
  // 这里throw后面抛出了一个类型为const char*的异常，因此，需要在catch块中捕捉该类型，然后输出，会输出Division by zero condition!
  ~~~

  使用C++底层库里面的函数报错时，C++底层库会报出一系列的标准的异常，比如new操作失败、[]操作符如下：

  ![image-20231211143203814](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20231211143203814.png)可以通过继承和重载 **exception** 类来定义新的异常。重写what方法定义该异常类型的描述。==其中**const throw()不是函数，这个东西叫异常规格说明**，表示what函数可以抛出异常的类型，类型说明放到()里，如果()里面没有任何类型，表示该函数不能抛出任何异常，与no except关键字作用一样==， ==**抛异常语句自己不能抛异常。**==

  ==注意如果真的在throw()或者no except标识的语句中遇到了异常，C++会直接调用std::terminate终止程序。`std::terminate`会调用用户定义的终止处理程序，默认情况下这个处理程序会调用`std::abort`。用户可以通过`std::set_terminate`函数来设置自定义的终止处理程序。==

  ~~~cpp
  #include "iostream"
  #include "exception"
  using namespace std;
   
  // 自定义新的异常
  struct MyException: public exception{
      const char * what() const throw(){  // what()是异常类提供的一个公共方法，它已被所有子异常类重载,这将会返回异常产生的原因。
          return "C++ Exception!";
      }
  };
  try{
      throw MyException();
  }catch(MyException &e){
      cout << "MyException caught: ";
      cout << e.what() << endl;
      
  void mightThrow(); // could throw any exceptions.
  void doesNotThrow() noexcept; // does not throw any exceptions.
  void old_stytle() throw();  // does not throw any exceptions.
  void new_style() noexcept;  // does not throw any exceptions.
  /*
  * 总的来说，异常是一个类型，what函数有对应的描述。所谓抛出异常，其实就是抛出一个异常的实例类，外部catch到该实力类可以做一些事。一个函数默认可以抛出任何类型的异常对象，如果加了throw()异常规格说明，则只能抛出规格说明内的（没有则不准抛）。关键字no except也是表示不准抛异常。
  */
  ~~~

- std::set方法的构造函数都需要以一个表式数据构造，比如可以用vector、数组、迭代器等构造。

- `template <>`: 这表示接下来要进行一个模板的特化（specialization）。

  `void myFunction<int>(int value)`: 这是对模板函数 `myFunction` 的特化，指定了模板参数为 `int`。这意味着当你调用 `myFunction` 时，如果参数的类型是 `int`，编译器会选择使用这个特定的实现。

  注意需要放在std命令空间内，不能在std的子空间内，比如什么ZSoft

- 在所有允许的情况下，*空指针*类型*转换*为不同的*空指针*类型后仍然是**空指针**。

- 在C++中，声明 `int a, b, c = 0;` 会初始化变量 `c` 为0，但不会初始化 `a` 和 `b`。这是一个常见的误解，因为在C++中，每个变量都需要独立进行初始化。如果要同时进行初始化，需要分别写初始化语句，也可以使用逗号分割，int a = 0, b = 0, c = 0;

- 使用`std::swap(arr[i], arr[i+1])`进行数组内元素的交换（==注意要保证arr不是const，而是可修改的==），在C++中描述一个数据可以用==地址+类型或者一段内存（变量名）==来标识，swap传入的参数需要是两段内存，然后通过move交换两段内存里面的数据。

- static的坏处就是不能多态；直接用指针访问是可以多态的，如果是一个被重写的方法，基类通过指针调用可以做成延迟反射算法，如果通过static方法调用会一直调用的是基类逻辑。

- 有符号和无符号的值的范围：

  有如下中间结论：

  > 1 无符号和有符号的数据都可以从0开始
  >
  > 2 unsigned long和unsigned int表示的数值区间完全一样
  >
  > 3 **int和unsigned long都为4个字节，表示的数值区间范围为2*E32**
  >
  > 4 int的范围为（-2147483648， 2147483647），即-2\*E31~2\*E31-1
  >
  > 5 unsigned long与int的区间范围一样大，但是起点从0开始，相当于向右移动了1/2
  >
  > 6 如果内存上的-1的值被解析为unsigned long，结果会被输出为4294967295
  >
  > 7 ![image-20240105153016071](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240105153016071.png)

  | 类型名称        | 字节 | 值的范围                       |
  | :-------------- | :--- | :----------------------------- |
  | int             | 4    | -2,147,483,648 到2,147,483,647 |
  | unsigned int    | 4    | 0 到4,294,967,295              |
  | __int8          | 1    | -128 到127                     |
  | unsigned __int8 | 1    | 0 到255                        |

- `new (&data.nArray[0]) array(3)`这是一个使用定位 new 运算在内存中构造数组的表达式，通常用于在已分配的内存区域上创建对象。

  ~~~cpp
  用法为new 地址 对象，在指定内存地址上创建一个对象。
  template<typename T, typename G>
  void Variant::initArray(ZUINT 32, ZLENGTH iInitSize)
  {
      if (this->hasArrayFlag())
      {
          throw;
      }
      if (type > kLastBuiltInType)
      {
          d.type = type | VariantType::kArrayFlag;
          new (&d.data.mArray[0] Array<T, G>(iInitSize));
      }
      else
      {
          throw;
      }
  }
  ~~~


- `std::is_base_of<RxObject, T>::value` 是 C++ 中的类型特征（type trait），用于检查类型 `RxObject` 是否是类型 `T` 的基类。这是通过**模板元编程**中的 `std::is_base_of` 类模板来实现的。

  具体来说：

  - `std::is_base_of<RxObject, T>` 是一个模板类，用于检查 `T` 是否是 `RxObject` 的基类（或者是否与 `RxObject` 相同）。
  - `::value` 是模板类中的静态成员，它表示检查的结果。如果 `T` 是 `RxObject` 的基类（或相同），`value` 将为 `true`，否则为 `false`。

  下面是一个示例，说明如何使用 `std::is_base_of`：

- `static_assert` 是 C++11 引入的一种静态断言机制。它允许在编译时进行断言检查，如果条件为假，则导致编译错误。`static_assert` 主要用于进行**编译时的一些静态约束检查**，而不是在运行时进行检查。

- unordered_map中使用emplace插入两个相同的key时，emplace会插入失败，但是不会报错，此次插入操作无效。

- C++中如果需要一些C++类型的动态变化，比如有些时候需要用String做key，有时候用ObjectId做key，可以考虑模板。注意模板类可以由普通类派生，==但是普通类继承自模板类时需要将模板实例化==

- C++ 的 `std::unordered_set` 不能保证遍历顺序的稳定性。`std::unordered_set` 是使用哈希表实现的，哈希表中元素的存储顺序是根据哈希函数计算出来的，而不是元素被插入的顺序。因此，遍历 `std::unordered_set` 得到的元素顺序是不稳定的，它可能在不同的运行环境下、甚至同一次运行的不同时刻都会有所不同。

  如果你需要稳定的遍历顺序，应该使用 `std::set`，它是基于红黑树实现的有序集合，能够保证元素的遍历顺序是稳定的，且按照元素的大小顺序排列。
  
  ==对于 `std::unordered_set::emplace` 方法，它的返回值是一个 `std::pair` 对象，包含一个迭代器和一个布尔值。迭代器指向插入元素的位置，而布尔值表示是否插入成功。==

- C++内部类InnerClass可视为外部类的友元，可以访问他的任何成员变量和成员方法。但是除此之外他其实还是一个比较独立的类，不属于外部类的继承，==自带的this指针也没有外部类的非静态成员方法，要访问非静态成员方法，还是需要通过外部类的对象访问==。

  > - **==C++不允许内部类型的前置声明，这个内部类型包括 内部类 与 内部typedef类型！==**
  >
  > ~~~cpp
  > <1>
  > class Container::Iterator;
  > void Fun(Container::Iterator iter)
  > {
  >   // 编译报错
  > } 
  > class Container {
  >     class Iterator{
  >     }
  > }
  > <2>
  > class Container::Iterator;
  > void Fun(Container::Iterator iter)
  > {
  >   // 编译报错
  > } 
  > class CC_Iterator{
  > }
  > class Container {
  >     typedef CC_Iterator Iterator;
  > }
  > ~~~
  >
  > - ==类声明的位置决定了类的作用域（或可见性）。类可见后，访问控制规则将决定程序对嵌套类成员的访问权限。==比如声明再保护中，只是决定了这个内部类对子类可见，**但是内部类对于外围类的访问控制依旧是private友元级别，即能通过实例或者实例指针访问所有成员数据**。

- 在C++中，模板本身不能被继承或派生。==模板是用来生成类或函数定义的蓝图==，它们在编译时被实例化以生成具体的类或函数。因此，模板本身并不是类或对象，所以无法被继承或派生。 

- 优先队列是一种特殊的队列，其中每个元素都有一个优先级，高优先级的元素先出队。在C++中，可以使用STL中的priority_queue实现优先队列，它底层是用堆（heap）实现的。

  堆是一种完全二叉树，可以分为小根堆和大根堆。在大根堆中，每个节点的值都不小于它的子节点，堆顶元素是堆中最大的元素。在小根堆中，每个节点的值都不大于它的子节点，堆顶元素是堆中最小的元素。

  在C++中，priority_queue默认使用大根堆。可以通过指定模板参数，改为使用小根堆。

- 获取Map中的最后一个元素可以使用rbegin()和rend()函数。其中，rbegin()函数返回反向迭代器指向Map的最后一个元素，而rend()函数返回反向迭代器指向Map的第一个元素前一个位置。因此，只需要使用rbegin()函数来访问Map的最后一个元素即可。

  以下是一个简单的示例代码，展示了如何使用rbegin()函数来获取Map中的最后一个元素：

  ```cpp
  #include <iostream>
  #include <map>
  int main()
  {
    std::map<int, std::string> myMap;
    myMap[1] = "apple";
    myMap[2] = "banana";
    myMap[3] = "orange";
    
    std::map<int, std::string>::reverse_iterator it = myMap.rbegin();
    std::cout << "the last element is: " << it->second << std::endl;
    
    return 0;
  ```

- 左值、将亡值还是纯右值，都是表征了表达式的属性，而这种属性的区别主要体现在使用上，如**能否做运算符的左操作数**、**能否使用移动语义**等。

  >- **能够用&取地址的表达式是左值表达式**
  >  函数名和变量名（实际上是函数指针和具名变量，具名变量如std::cin、std::endl等）、==返回左值引用的函数调用==、前置自增/自减运算符连接的表达式++i/--i、由赋值运算符或复合赋值运算符连接的表达式(a=b、a+=b、a%=b）、解引用表达式*p、字符串字面值"abc"（关于这一点，后面会详细说明）等。
  >
  >- **纯右值**
  >     满足下列条件之一：
  >     1）本身就是赤裸裸的、纯粹的字面值，如3、false；
  >     2）求值结果相当于字面值或是一个不具名的临时对象。
  >      举例
  >     除字符串字面值以外的字面值、**返回非引用类型的函数调用**、后置自增/自减运算符连接的表达式i++/i--、算术表达式（a+b、a&b、a<<b）、逻辑表达式（a&&b、a||b、~a）、比较表达式（a==b、a>=b、a<b）、取地址表达式（&a）等。
  >
  >    1）++i是左值，i++是右值。
  >     前者，对i加1后再赋给i，最终的返回值就是i，所以，++i的结果是具名的，名字就是i；而对于i++而言，是先对i进行一次拷贝，将得到的副本作为返回结果，然后再对i加1，由于i++的结果是对i加1前i的一份拷贝，所以它是不具名的。假设自增前i的值是6，那么，++i得到的结果是7，这个7有个名字，就是i；而i++得到的结果是6，这个6是i加1前的一个副本，它没有名字，i不是它的名字，i的值此时也是7。可见，++i和i++都达到了使i加1的目的，但两个表达式的结果不同。
  >
  >     2）**解引用表达式\*p是左值，取地址表达式&a是纯右值**。
  >     &(*p)一定是正确的，因为*p得到的是p指向的实体，&(*p)得到的就是这一实体的地址，正是p的值。由于&(*p)的正确，所以*p是左值。**而对&a而言，得到的是a的地址，相当于unsigned int型的字面值，所以是纯右值**。
  >
  >     3）a+b、a&&b、a\==b都是纯右值
  >     a+b得到的是不具名的临时对象，而a&&b和a\==b的结果非true即false，相当于字面值。
  >
  >- **将亡值**
  >     在C++11之前的右值和C++11中的纯右值是等价的。**C++11中的将亡值是随着右值引用的引入而新引入的**。换言之，“将亡值”概念的产生，是由右值引用的产生而引起的，将亡值与右值引用息息相关。所谓的将亡值表达式，就是下列表达式：
  >     1）==返回右值引用的函数的调用表达式==
  >     2）==转换为右值引用的转换函数的调用表达式==
  >
  >  在C++11中，我们用左值去初始化一个对象或为一个已有对象赋值时，会调用拷贝构造函数或拷贝赋值运算符来拷贝资源（所谓资源，就是指new出来的东西），而当我们用一个右值（包括纯右值和将亡值）来初始化或赋值时，会调用移动构造函数或移动赋值运算符来移动资源，从而避免拷贝，提高效率（关于这些知识，在后续文章讲移动语义时，会详细介绍）。当该右值完成初始化或赋值的任务时，它的资源已经移动给了被初始化者或被赋值者，同时该右值也将会马上被销毁（析构）。也就是说，==当一个右值准备完成初始化或赋值任务时，它已经“将亡”了。而上面1）和2）两种表达式的结果都是不具名的右值引用==，它们属于右值（关于“不具名的右值引用是右值”这一点，后面还会详细解释）。又因为
  >      1）这种右值是与C++11新生事物——“右值引用”相关的“新右值”
  >      2）这种右值常用来完成移动构造或移动赋值的特殊任务，扮演着“将亡”的角色
  >      所以C++11给这类右值起了一个新的名字——将亡值。
  >
  >  ==不具名的意思就是，没有在内存中为其分配属于他的资源，它们通常存储在CPU寄存器或栈上，以便进行快速计算和操作。 当编译器遇到一个右值表达式时，它通常不会为其分配内存，而是将其计算结果存储在寄存器或栈上。 左值是可以放在赋值号左边可以被赋值的值；左值必须要在*内存中*有实体； *右值*当在赋值号右边取出值赋给其他变量的值；*右值*可以在*内存*也可以在CPU寄存器。==
  >
  >- 相对而言，右值则是一个临时值，常在调用函数时出现，代表了一个由编译器创建的临时内存空间，以保存由函数返回的值，它不能被程序的其他部分访问。该内存空间仅被访问一次，之后就不再能被访问。
  >
  >  C++11 引入了右值引用的概念，以表示一个本应没有名称的临时内存空间。
  >  右值引用的声明与左值引用类似，但是它使用的是 2 个 & 符号（&&)
  >
  >  左值引用，int &p=x; 实际上是给已有名字为 x 的一块内存空间起了个别名 p
  >
  >  而右值引用，int && rRef = square(5); 就是给没有名字那一块，本该是临时内存空间的内存空间起了个名字，并且可以通过名字多次访问这块内存空间
  >
  >  通过取址符还能取到这块内存空间的地址：
  >  cout << &rRef << endl;
  >  004FFC44
  >
  >  也能通过名字 rRef 改变这块内存空间里的值：
  >
  >  ```cpp
  >  rRef=6;
  >  ```
  >
  >  在初始化完成之后，square(5)所创建的临时内存空间就有了一个名称，即 rRef1，所以 rRef1 本身变成了一个左值。
  >
  >  这意味着后面的这个初始化语句将不会编译：
  >
  >  int && rRef2 = rRef1;
  >  究其原因，就是右侧的 **C++不允许内部类型的前置声明，这个内部类型包括 内部类 与 内部typedef类型！** rRef1 不再是一个右值（没家室的人有了家室之后，变成了有家室的人，那你一样不能勾搭了）。
  >
  >  综上所述，临时内存空间最多可以有一个右值引用指向它。

- 一般而言，返回值为非引用类型的函数调用返回的是一个右值（比如像map等容器的begin方法拿到迭代器），不可以被左值引用&取别名，但是如果const auto&却是可以的，这是因为auto自动推断了iterator&，从而变成了一个右值引用，给临时右值强行取了一个别名变成了将亡值，在非移动赋值的情况下，这是比较危险和影响效率的，因为右值实际所在的内存空间有可能是内存或者寄存器，要尽快释放。

- ==注意，不要将函数栈内部的变量以右值引用的方式传出，因为出函数栈后，变量会被析构，这个时候外部使用这个变量就会访问非法地址而崩溃。==比如以下代码（C++是允许局部变量以出参对象的资源的形式绑定至子对象的引用）：

  ~~~cpp
  struct OParam
  {
      const int& i;
      string s;
  }
  void func(OParam& pm)
  {
      int f = 1;
      return {f};
  }
  OParam prm;
  func(prm);  // 运行时会崩溃，因为prm出参的子对象绑定至了一个已析构值的引用
  ~~~

- 在线性表中，元素个数可以为零，称为空表；

  在树中，结点个数可以为零，称为空树；

  在图中，顶点个数不能为零，但可以没有边。

- 字节(Byte):通常将可表示常用英文字符8位二进制称为一字节。

  一个英文字母(不分大小写)占一个字节的空间，一个中文汉字占两个字节的空间．
  符号：英文标点占一个字节，中文标点占两个字节．

  1字节(Byte） = 8位(bit)

  比特(Bit)，亦称二进制位。新港台：位元

  比特指二进制中的一位，是二进制最小信息单位。
  1比特就是1位

  ==一个16进制的一个UUID实际上是128位bit的编码（由32个16进制的字符组成）==

- <a id="函数调用操作符"></a>一个结构体如果重载了operator()函数调用操作符，则该结构体成为了一个callable的类型。对于该类型的结构体，在直接使用时可以隐式调用函数操作符，直接使用A（参数）调用operator()下的逻辑；在需要传入一个callable类型时，可以将该结构体名称直接传进去。

  >注意在std::unordered_map和std::sort中第三个参数需要传入的callable对象细节不太一样，具体是，unordered_map需要传入的是一个callable对象的类型，内部会自己实例化并计算；而std::sort则要求直接传入一个callable的对象，因此需要传入A()而不是A。
  >
  >在使用 `std::unordered_map` 时，你需要传递一个哈希函数对象的类型作为模板参数，而不是一个实例。这是因为 `std::unordered_map` 在内部会创建一个哈希函数对象的实例来计算键的哈希值。
  >
  >所以，在 `std::unordered_map` 中，你需要传递哈希函数对象的类型，而不是一个实例。例如，你可以直接使用 `MyHash`，而不是 `MyHash()`。
  >
  >而在 `std::sort` 中，你需要传递一个具体的函数对象实例作为排序准则，因此需要使用 `MyHash()` 来创建一个 `MyHash` 类的实例。
  >
  >总之，`std::unordered_map` 中的哈希函数对象是作为类型传递的，而 `std::sort` 中的排序准则是作为函数对象实例传递的。

- c++中不能在全局作用域中使用对象的操作符，总是会将该对象解释为类型，要使用可以包装一个工具类，公共类的构造作用域完成某些注册逻辑。

- 在使用宏函数时，注意宏参数如果传入的是限定作用域的枚举（类似A::B），展开后，宏函数里面会真的直接替换为A::B, 这时候如果使用了连接符C##D，然后将D替换，会变成C##A::B, 作用域会被突然改变，而不可控。因此在使用连接符##，最好保证前后参数为裸参数/类型名。==根据目前使用的经验，宏参数只能传参数/类型名，或者常量==。

- C++在函数参数传递的时候虽然声明形参是const左值引用，但是可以传递右值进去，但是形参声明为普通左值引用就不可以。

- 在编译选项中加上`-fno-elide-constructors`，可以让使用临时值赋值/拷贝构造时，不要被编译器基于移动语义将临时值优化掉。参考man手册, 节选自man g++部分

  ~~~cpp
  The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type.
  Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases.
  ~~~

- **volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改**，比如：操作系统、硬件或者其**它线程**等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：**int volatile vInt;** 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：

  ```
  volatile int i=10;
  int a = i;
  ...
  // 其他代码，并未明确告诉编译器，对 i 进行过操作
  int b = i;
  ```

  volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

  - “特殊”的内存不行。最常见的“特殊”内存是用来做内存映射I/O的内存。这种内存实际上是与外围设备（比如外部传感器或者显示器，打印机，网络端口）通信，而不是读写通常的内存（比如RAM）。总之，内存上的修改并不通过程序的写操作执行，而直接通过内存映射。

- **对全序容器，`std::set` 和 `std::map` 都不需要额外重载 `=` 运算符来判断元素是否相等。它们都是通过比较函数来实现元素的顺序和唯一性的判断。**具体来说：

  1. **`std::set`**：比较函数（默认是 `std::less<T>`）用于判断集合中的元素顺序。由于 `std::set` 中的元素是唯一的，如果两个元素满足 `!(a < b)` 和 `!(b < a)`，它们被视为相等。
  2. **`std::map`**：比较函数（默认是 `std::less<Key>`）用于判断键的顺序。由于 `std::map` 中的键是唯一的，如果两个键满足 `!(a < b)` 和 `!(b < a)`，它们被视为相等。

  ==因此，对于此类容器，仅需重载，或者模板实例化比较仿函数而不用额外定义\=号运算符。同时容器使用的<比较运算符必须要是稳定的，即使遇到空指针等额外情况也必须是稳定的，不稳定情况多用false。==
  
  对于std::sort也是，==要保证严格弱序/线性顺序，== 当两个元素相等时，比较器应返回`false`。这是因为`std::sort`需要一个严格弱序关系，`comp(a, b)`和`comp(b, a)`同时为`false`表示`a`和`b`等价。

- C++中的math库中的atan2(a,b)是带四象限的反正切，它的取值不仅取决于正切值a/b，还取决于点 (b, a) 落入哪个象限：
     当点(b, a) 落入第一象限时，atan2(a,b)的范围是 0 ~ pi/2;
        　当点(b, a) 落入第二象限时，atan2(a,b)的范围是 pi/2 ~ pi;
     当点(b, a) 落入第三象限时，atan2(a,b)的范围是 －pi～－pi/2;
        　当点(b, a) 落入第四象限时，atan2(a,b)的范围是 -pi/2～０

  而 atan(a/b) 仅仅根据正切值为a/b求出对应的角度 （可以看作仅仅是2象限反正切）：
     当 a/b > 0 时，atan(a/b)取值范围是 0 ~ pi/2；
     当 a/b < 0 时，atan(a/b)取值范围是 -pi/2～０

- 无论是typename...还是...还是预定义宏\_\_VA\_ARGS_\_\_核心思想都是给可变参数一个类型名(typename ...)和参数名。

- C++中，后缀自增运算符(a++)和前缀自增运算符(++a)的区别在于**返回值的不同，但是a本身最后都会+1**，前者会返回a原本的值（因此需要拷贝），后者会返回+1后的值（因此不需要拷贝）。

- 在C++中，“empty” 并不是一个标准的术语，因此当调试时遇到“empty”可能意味着 `data` 的值没有被正确赋值，或者程序在解引用时遇到未定义行为（如果是指针，有很大可能是没有被初始化），导致数据不可用。

- 传入一个空指针下，std::function会构造一个有效但未绑定任何对象的对象，empty方法和operator bool()可以识别返回false，但是这个对象本身是有效的，==如果使用其来构造其他的方法（比如有一个callable对象作为成员函数的类）需要小心。==

- 因此，未初始化的指针**不会默认初始化**为 `nullptr` 或空指针。你需要显式地初始化指针以避免未定义行为。你可以将指针初始化为 `nullptr`（在 C++11 及更高版本中），或者在旧版本中初始化为 `NULL`。

- C++在进行变量声明时，都是类型+变量名范式，其中对于地址的变量名，有一个私有标记\*，带该**私有标记**的变量都表示其为一个地址（指针名）。用类型声明多个地址变量、初始化时，需要`GeCurve2d *pCrv1 = nullptr, *pCrv2 = nullptr`

- try catch性能损耗总结一下：
     如果不抛异常的话，其实性能是没多少影响的，或者说性能的影响微乎其微，几乎可以忽略不计。
     但是，如果抛异常了，这就会造成很大的性能影响。当抛异常的时候，需要去生成一个栈跟踪（stack track），
     这个主要是描述异常的相关信息，比如会对当时栈进行快照，记录栈帧所指向的类名，方法名，
     以及在哪一行代码上抛出的异常信息等等，这就是用异常捕获耗时的地方了。
     因此，在实际开发过程中，要适当捕获异常，而且仅捕获有必要的代码段。
     
- 在C++中，指针的比较操作可以用于确定两个指针是否**指向**相同的位置、一个指针是否指向的位置在另一个指针之前或之后等。

- 在C++的类中如果直接声明了一个结构体，但是并没有给类型名，意味着这是一个匿名的对象（非类型而是对象），里面的成员直接提升为类成员

     ~~~cpp
     // 非匿名，有类型名U
     class B {
     protected:
         union U {
             A a;
         };
     };
     
     // 匿名对象
     class B {
     protected:
         union {
             A a;
         };
     };
     ~~~

- 【C++的tryCatch无法捕获空指针/野指针异常】空指针实际上指向的是虚拟内存地址为 0 的位置，它是一个特殊的位置，操作系统内核是不会为应用程序在这个 0 地址上分配物理内存页的。因此当应用进程访问这个位置时，内核不会像访问常规内存那样：发现该处地址没有分配物理页面，会产生一个缺页异常，然后异常处理程序为它分配一个物理页，并建立页表项，而是直接向进程抛出一个内存段错误的信号：SIGSEGV。我们知道，这个信号的缺省处理是终止进程并生成 coredump 文件，因此，当程序访问空指针时，内核会直接终止进程，也就是应用程序根本不会有抛出异常的机会，实际上应用程序压根就不知道它访问了空指针，因为它自己判断不了，抛异常也就无从谈起，所以尽管上述 C++ 程序使用了 catch 语句块，也没有异常可捕捉。同样，如果程序访问一个指向不属于进程地址空间的指针（也可以说是野指针，通常是编程错误造成的），它所指向的内存位置是无效线性地址，同样操作系统内核也会直接产生一个 SIGSEGV 信号，终止进程。

- 一般情况下，直接使用常量0， 1等，会被推导为整型。如果标明使用无符号整型，可以在常量后面加上类型标识类似0ull, 1ull等。

- **枚举值的值如果使用表达式类似a+5, a<<1等，其值在编译期就会被确认，不会影响运行期性能。**

- 【右值引用，引用折叠，完美转发，移动语义】

  - 了解引用折叠（reference collapsing）

    - 引用有左值引用和右值引用，引用实际上是同一内存段的别名。

    - 只要两个引用中的一个为左值引用的话，则折叠为左值引用，否则为右值引用。$\to$**这种条件取值就赋予了编码的灵活度。**

    - 应用场景

    > 1 万能引用实例化
    >
    > `template <typename T>`
    >
    > `void func(T&& param)`  // 不显式指定的情况下，T参数的推导取决于param的传值类型
    >
    > 2 std::forward机制
    >
    > `template <typename T>`
    >
    > `T&& forward(typename remove_reference<T>::type& param)`  // 函数/类模板使用嵌套类型需要typename标识
    >
    > `{return static_case<T&&>(param)}`（T是什么类型，传出的就是什么类型）
    >
    > 3 auto类型推导
    >
    > auto&& type = param;
    >
    > 也可以根据param的类型自适应声明type的类型

  - 移动语义是一种思想，基于std::move将对象变为右值引用以转移所有权；万有引用也是一种思想/概念，移动语义要求对象具有右值引用构造，这就要求对象在进行编码时同时编写左值构造与右值构造，为简化编码，提出了万有引用（类似于模板），基于传参动态识别左值与右值；为了实现万有引用的动态识别，规定了引用折叠规则，以及std::forward完美转发模板，在A(const A&& a)中，a可以是左值与右值，而在实现中使用std::forward可以完美转发A的引用状态。
  - 完美转发是为了解决在参数表传递中的==值和类型的保持问题==。因为目前可以作为右值传入表达式的只有右值表达式的值、字面量等，其中**不包括单纯的变量，哪怕这个变量是由参数表中右值传递过来的变量也一样，传递完之后他就变为了左值！**

- 了解auto类型推导 `auto a = {expression}`
  
  - auto类型推导一般情况下会应用stripping机制，剥除右侧表达式的c, v关键字以及引用。**如果希望保留表达式返回值的c, v标识和引用，则需要显式的添加。考虑到C++引入了左右值的区分，由此产生了const auto&, const auto &&， auto&和auto&&**
  - 需要注意的情况是，在推导中显式标明需要保留引用的情况下，为了不破坏右侧表达式返回值的语义，返回值如果有const也会随之保留。即对于`auto& a = b`的情况，如果b是一个const左值，则auto也会保留const，而不引用stripping机制。
  - const auto&常引用比较特殊，猜测是历史遗留问题，作为左值引用可以绑定右值，是C++早期提供的编码语法糖。
  - auto&& 通用引用，比较特殊，显式添加&&情况下，基于引用折叠技术，可以同时对左值和右值进行保留引用。
  - const auto&& 基于显式声明保留const以及&&右值引用
  
- const auto&与auto&&

  ~~~cpp
  template <typename U, typename V>
  auto add(U a, V b) -> decltype(a + b);
  // 中auto只是作为一个占位符，真正的返回类型使用decltype推导，这样可以简化编码量，进行动态元生成。
  // 总的来说，auto作为占位符可以满足动态生成。
  //C++14可以简化为如下
  decltype(auto) func(T parameter)
  {
      return something;
  }
  ~~~

​		因此，const auto&和auto&&的区别就是，虽然他们都能绑定右值，但是const auto&额外声明保留了const符号；auto&&则不会保留const符号，但是他们都能同时绑定左值和右值（通用引用与特殊左值常引用）。

- unique_ptr的初始化方式

  ① 调用make_unique\<type\>(value)在定义进行赋值；

  ② 与shared_ptr和auto_ptr一样，可以使用调用new/new[]返回的指针去初始化unique_ptr指针； 

  使用new返回的堆区指针去在定义时初始化unique_ptr指针可以，**但是在定义完成后，使用new返回的堆区指针是不可以赋值给unique_ptr指针**。

  unque_ptr支持移动构造但是不支持拷贝构造，因此要使用std::move做移动语义

- C++终止程序exit, abort和terminate的区别

  - **`exit`**：进行部分清理并正常结束程序。

  - **`abort`**：立即终止程序，不进行清理，通常用于紧急退出。

  - **`terminate`**：在异常处理中使用，通常调用 `abort`。

- 各变量初始化时机：

  - 变量初始化遵循更早的静态处理以及更节省的内存分配
  - 对于非const的static静态全局变量/类的成员变量，在类外进行定义，且在第一次用到时进行初始化。
  - 对于const的static变量，考虑到其const属性，在编译期就执行了初始化并分配内存（全局区）；更激进的，对于static const的整型或枚举，程序甚至不会分配内存，而是类似于宏的文本替换，只有当需要取地址时，才会分配内存。

- **智能指针类**：当你实现一个类似智能指针的类时，通常需要重载 `operator->()`，这样在使用类似指针的语法（如 `ptr->method()`）时，它可以正确地返回对象的指针，方便访问该对象的成员。

  **代理类**：当你希望通过某个类访问另一个类的成员时，重载 `operator->()` 可以返回另一个类的指针，从而间接访问它的成员。

- 【多线程，容器查找解决方案】对于大容量线性容器的查找，可以考虑基于多线程优化查找效率，具体实现是对容器索引/迭代器分组，确定一个步长后，组内迭代器并行查找。

- 【C++格式化输出】

  %d	以十进制形式输出带符号整数(正数不输出符号)
  %ld	以十进制形式输出带符号long整数(正数不输出符号)
  %o	以八进制形式输出无符号整数(不输出前缀0)
  %x, %X	以十六进制形式输出无符号整数(不输出前缀Ox)
  %u	以十进制形式输出无符号整数
  %f, %lf	以小数形式输出单、双精度实数
  %e, %E	以指数形式输出单、双精度实数
  %g, %G	以%f或%e中较短的输出宽度输出单、双精度实数
  %c	输出单个字符
  %s	输出字符串
  %p	指针的值

- 【C++，构造函数，基类，派生类构造，析构】派生类构造函数如果没有显式调用基类的构造函数，那么就会自动隐式调用基类的无参数的构造函数。同样，在析构时，在调用完派生类析构函数后，会隐式调用基类的析构函数。

- 【前置声明，struct与class区别】struct不能用作前置声明，class才能被用作前置声明。

- 【访问权限，构造时机】C++的访问权限与构造时机并不冲突，即使A是一个static constexpr对象，也可以将其构造访问权限限制在private，开放一个友元类构造一个static constexpr的他。

- 【匿名结构体】匿名结构体struct，好处是可以逻辑上分组数据而不增加数据的访问层次，但是由于匿名结构体没有名字，编译器无法单独识别它，无法定义构造函数或赋值运算符。

- 【箭头操作符】箭头操作符实际上是解引用和点操作符两个行为打包的简写，行为为返回一个对象的指针，语义为解引用和点操作符。而重载箭头操作符只改变了箭头符号的行为，而不改变其语义。==注意->操作符比较特殊，有解引用和点操作符的特殊语义，类似的还有右值引用操作符，有移动语义，这是编译期对操作的特殊行为。==

- 【指针，指针比大小】一般只有指向同一数组对象的元素的指针比较才有意义，可以被视为迭代器的偏移量比较；初次之外编译期并没有对对象在内存中的相对位置做出规定，属于未定义行为。**唯一空指针的比较有一定意义，空指针被认为小于任何非空指针。**

## 文件与日志

- 在32位机器中，%d, 和%ld都表示32位（int, long），而%lld表示64位整型占位符。但是在64位机器中%ld表示的long就是64位的

## 字符串操作

- 截取子串

         s.substr(pos, n)    截取s中从pos开始（包括0）的n个字符的子串，并返回
          
         s.substr(pos)        截取s中从从pos开始（包括0）到末尾的所有字符的子串，并返回


- 替换子串

  ~~~cpp
   s.replace(pos, n, s1)    用s1替换s中从pos开始（包括0）的n个字符的子串
  ~~~


3. 查找子串

       s.find(s1)         查找s中第一次出现s1的位置，并返回（包括0）
       
       s.rfind(s1)        查找s中最后次出现s1的位置，并返回（包括0）
       
       s.find_first_of(s1)       查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括0）
       
       s.find_last_of(s1)       查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括0）
       
       s.fin_first_not_of(s1)         查找s中第一个不属于s1中的字符的位置，并返回（包括0）
       
       s.fin_last_not_of(s1)         查找s中最后一个不属于s1中的字符的位置，并返回（包括0）

## C++11特性

- C++11引入了继承构造函数（inheriting constructors）特性，它允许派生类基于using关键字自动继承基类的构造函数。(**注意：如果C++显式的定义某个签名下的构造函数，会阻止基于using隐式生成对应的继承构造函数**)

  ~~~cpp
  class Derived : public Base
  {
      // 传统方法
      public:
      Derived(int x) : Base(x){}
      
      // C++11
      using Base::Base;  // 继承基类的所有构造函数
  }
  // 通过using A::A的声明。将基类中的构造函数全继承到派生类中，更巧妙的是，这是隐式声明继承的。即假设一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。
  ~~~

- `std::begin()` 在 C++11 中引入，它是用于泛型编程的重要工具，使得代码能够更加通用，并且能够方便地处理不同类型的容器和数组。

- C++11引入了变长模板参数（variadic templates），允许接收任意数量的参数，在编写泛型库、元编程、以及需要处理不定数量参数的场景有应用。

  ~~~cpp
  1 变长模板参数可以让你定义一个模板，接受任意数量的参数
  template<typename... Args>
  void print(Args... args) {
      (std::cout << ... << args) << std::endl;
  }
  
  int main() {
      print(1, 2, 3);          // 打印 1 2 3
      print("Hello", "world"); // 打印 Hello world
  }
  2 递归处理参数包
  3 变长模板参数允许你编写更灵活和通用的模板，尤其是当你需要处理多种类型时。它还用于元编程和类型萃取，帮助编译期计算和类型推导。
  template<typename... Types>
  struct Tuple {};
  Tuple<int, double, std::string> myTuple;
  ~~~

- **而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。**

- std::advance函数，std::advance (it,5);将迭代器前进到指定的位置上。std::begin, end, advance将迭代器的语义进行了封装。

- 【构造函数必要性优先级，默认构造函数生成规则】移动构造根据可移动性生成，拷贝构造A优先级大于默认无参构造B，即有B还是会生成A，但是有A不一定生成B。

## C++14特性

- 在C++14及其之后的版本中，可以直接使用 `greater<>`，而无需在模板参数中指定类型。这是因为C++14引入了泛型lambda和自动推导机制，`greater<>`可以自动推导容器元素的类型。

## C++17特性

- 对于变长模板参数，17引入了参数包展开的概念

  ~~~cpp
  template<typename... Args>
  auto sum(Args... args) {
      return (args + ...); // C++17 中的 Fold Expression
  }
  int main() {
      std::cout << sum(1, 2, 3, 4) << std::endl; // 输出 10
  }
  ~~~

  

# STL算法库

- `std::count_if` 是 C++ 标准模板库（STL）中的一个算法函数，用于统计符合特定条件的元素数量。
- std::advance(it, 5)将迭代器前进指定的步长。
- std*::*mismatch, 返回两个范围中第一个不同的位置 ;
-  std*::*equal, 测试两个范围内的元素是否相等 ;
-  std*::*is_permutation, 检查一个序列是不是另一个序列的排列.
- std::all_of, std::none_of和std::any_of
- std::pow做指数运算，注意C++不支持**，同时^在C++中表示异或

# Type_Traits

- 【引用】`std::ref` 和`std::cref` 通常用来产生一个reference_wrapper对象
- 【引用】`reference_wrapper `常通过引用传递对象给`std::bind`函数或者`std::thread`构造函数
- 【引用】普通的引用不是对象，所以无法存入任何标准库容器（除常引用const A&）。`reference_wrapper`包装的引用就可以被存入容器中，并通过.get()方法取引用。
- 【const常引用，reference_wrapper，成员变量】const常引用和reference_wrapper都可以使用引用来作为类的成员变量。但是他们的灵活性不一样，const常引用由于其不可变的性质，只能在==构造时初始化列表或者默认构造==进行绑定，绑定是**立即完成，且不可变更的**。而std::reference_wrapper\<A\>是可以重新绑定的。另外const常引用不具备值语义，没有拷贝构造和赋值操作，因此不兼容基本容器（需要支持拷贝），而std::reference_wrapper是一个模板对象，具有值语义，可以兼容基本容器。基于reference_wrapper可以把对象当指针使用，享用同一份资源。与直接使用裸指针相比，他不负责管理生命周期，相对的，调用者需要保证逻辑内引用对象资源的完整，适合局部流程使用。裸指针自己管控着生命周期，在使用作用域上更加灵活。

# QT相关


- 【QT计时器】 `QTimer` 是 Qt 框架中用于计时的类，用于在指定的时间间隔后触发事件或信号。其用法示例如下：

     ~~~cpp
     // 创建一个 QTimer 对象
     QTimer *timer = new QTimer(this);
     
     // 连接超时信号到相应的槽函数
     connect(timer, &QTimer::timeout, this, &YourClass::onTimeout);
     
     // 启动计时器，每 1000 毫秒（1 秒）触发一次超时信号
     timer->start(1000);
     
     timer->remainingTime();
     
     // 停止计时器
     timer->stop();
     
     // 调用start会开始计时，每间隔一定事件会触发超时信号
     // 调用stop会停止计时
     // remainingTime是距离下次超时的剩余事件
     // setSingleShot用于设置是否单次触发
     ~~~

# C++多线程

- C++使用std::thread提供多线程能力，为了保证线程安全，一般线程在进行执行时，需要申请互斥锁(std::mutex)

- std::mutex，锁是一个对象，该对象提供了lock、unlock等接口实现对数据的锁定保护。为了更方便的管理锁的lock,unlock的时机，提供了std::lock_guard管理，构造时调用mutex.lock，析构时调用std::mutex.unlock.**std::mutex对象将lock和unlock之间的代码变为了全局唯一，一个线程调用到该代码后就拥有了该全局性。**

- std::atomic<...> （atomic原子的），`std::atomic`是C++11标准库中提供的一个模板类，用于在多线程编程中进行原子操作。原子操作是指那些在执行过程中不会被中断的操作，它们在多线程环境下能够避免竞态条件。 `std::atomic`提供了一种高效且方便的方法来实现多线程中的原子操作，**避免了显式使用锁的复杂性和潜在的性能开销**。在需要对共享变量进行简单读写或基本算术操作时，`std::atomic`是一个非常有用的工具。

- std::atomic<>模板和volatile的区别与联系：

  - 在其他编程语言中（比如，Java和C#），`volatile`是有并发含义的，即使在C++中，有些编译器（早期的VC++）在实现时也将并发的某种含义加入到了`volatile`关键字中（但仅仅是在用那些编译器时）。

  - 对于并发使用std::atomic，对于特殊内存使用volatile。总的来说，**volatile不保证操作的原子性以及对代码重排顺序没有足够限制**。

  - std::atomic<>的实例化提供了一种在其他线程看来操作是原子性的的保证。一旦`std::atomic`对象被构建，在其上的操作表现得像操作是在互斥锁保护的关键区内，但是通常这些操作是**使用特定的机器指令**实现，这比锁的实现更**高效**。

  - 数据竞争的定义是同时存在多个readers和writers读取没有`std::atomic`或者互斥锁保护的内存。volatile只保证编译器每次取数据都从内存中取，但不保证不同线程对该数据的读写操作的原子性，比如：

    ~~~cpp
    // volatile
    volatile int vi(0);             //初始化vi为0
    vi = 10;                        //设置vi为10 
    std::cout << vi;                //读vi的值
    ++vi;                           //递增vi到11
    --vi;                           //递减vi到10
    // 在A线程读取vi值时，有可能在其他线程已经将vi修改为其他值了，这四条针对vi的读改写操作并没有被包装保证原子性。
    // 每个自增操作包括了读取vi的值，增加读取的值，然后将结果写回到vi。即使是这三个操作对于volatile对象不能保证原子执行，所以可能Thread1读取vc的值，是0。Thread2读取vc的值，还是0。Thread1将读到的0加1，然后写回到vc。Thread2将读到的0加1，然后写回到vc。
    
    // atomic
    std::atomic<int> ai(0);         //初始化ai为0
    ai = 10;                        //原子性地设置ai为10
    std::cout << ai;                //原子性地读取ai的值
    ++ai;                           //原子性地递增ai到11
    --ai;                           //原子性地递减ai到10
    // 保证A线程针对ai的所有操作被包装成为一个原子，不会在操作过程中，被其他线程修改ai的值
    ~~~

  - std::atomic能保证**顺序一致性**。在\<atomic\>中定义了几种内存序模型。
    - memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见
    - memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见
    - memory_order_acq_rel：获得释放操作，一个读‐修改‐写操作同时具有获得语义和释放语义，即它前后的任何读写操作都不允许重排，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见，当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见
    - memory_order_seq_cst：顺序一致性语义，对于读操作相当于获取，对于写操作相当于释放，对于读‐修改‐写操作相当于获得释放，**是所有原子操作的默认内存序**（除此之外，顺序一致性还保证了多个原子量的修改在所有线程里观察到的修改顺序都相同；我们目前的讨论暂不涉及多个原子量的修改）

- 单线程和多线程的取舍，是根据硬件资源成本以及程序维护成本的权衡。

  - **单线程**
    -  **简单**：单线程编程更为简单，没有线程同步的问题，代码也更容易理解和维护。
    -  **资源浪费**：在现代多核处理器上，单线程程序只会使用一个CPU核心，而其他核心可能闲置，导致资源浪费。
  - **多线程的资源利用**：
    - **并行执行**：多线程程序可以利用多个CPU核心，提升计算速度和资源利用率。
    - **复杂性**：多线程编程增加了代码复杂性，需要处理线程同步、竞态条件、死锁等问题。

- std::future与async异步编程：

  - std::future是一个类模板（需要类型来实例化），存放了线程入口函数的返回结果。

  - std::promise也是一个类模板，可以基于std::promise实现线程之间的数据传输。

  - std::thread启动的线程不容易获取线程的计算结果；thread启动的线程如果抛出了异常，**且没有被线程本身处理时，会导致整个应用程序终止**；**std::future可以很方便地获取线程的执行结果，如果线程抛出了异常，std::future可以将异常转移到另一个线程中，让另一个线程来处理异常。**

  - [std::promise](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.cppreference.com%2Fw%2Fcpp%2Fthread%2Fpromise) 和 [std::future](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.cppreference.com%2Fw%2Fcpp%2Fthread%2Ffuture) 是 C++ 进行单向数据传递的一种方式。[std::promise](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.cppreference.com%2Fw%2Fcpp%2Fthread%2Fpromise) 是数据的输入端，[std::future](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.cppreference.com%2Fw%2Fcpp%2Fthread%2Ffuture) 是数据的输出端。同一个线程或者另一个线程将线程函数的计算结果放入到std::promise中，而std::future可以获取std::promise中存储的线程计算结果。因此，std::promise是线程计算结果的输入端，std::future是线程计算结果的输出端。

  - 使用std::promise需要注意的是：**`set_value`只能被调用一次，多次调用会抛出`std::future_error`异常**。事实上`std::promise::set_xxx`函数会改变std::promise的状态为ready，再次调用时发现状态已要是reday了，则抛出异常。

    `std::promise`实例是可以`MoveConstructible`(移动构造)和`MoveAssignable`(移动赋值)，但是不能`CopyConstructible`(拷贝构造)和`CopyAssignable`(拷贝赋值)。

  - std::future通过get()获取线程执行结果，如果线程尚未执行结束，对get()的调用将阻塞，直到该结果可以被获取。

    std::future可以先通过调用wait_for()方法，查询结果是否可用来避免阻塞。

    std::future只能调用一次get()成员函数来获取结果，继续调用多次会引发异常。

  - ==std::future这些东西都是主线程调，服务于线程之间的必要的同步，保证线程安全。==

  - ~~~cpp
    #include <iostream>
    #include <future>
    #include <chrono>
    
    // 定义一个异步任务
    std::string fetchDataFromDB(std::string query) {
        // 模拟一个异步任务，比如从数据库中获取数据
        std::this_thread::sleep_for(std::chrono::seconds(5));
        return "Data: " + query;
    }
    
    int main() {
        // std::async 是一个用于异步执行函数的模板函数，它返回一个 std::future 对象，该对象用于获取函数的返回值。
        // 使用 std::async 异步调用 fetchDataFromDB
        std::future<std::string> resultFromDB = std::async(std::launch::async, fetchDataFromDB, "Data");
    
        // 在主线程中做其他事情
        std::cout << "Doing something else..." << std::endl;
    
        // 从 future 对象中获取数据
        std::string dbData = resultFromDB.get();
        std::cout << dbData << std::endl;
    
        return 0;
    }
    ~~~

- std::lock_guard和std::mutex 的用法:

  - 二者均属于C++11的特性, std::mutex表示互斥锁的类, 而std::lock_guard是对锁在作用域内增加和销毁的监视，可以用std::mutex实例化

  - std::mutex属于C++11中对操作系统锁的最常用的一种封装，可以通过lock、unlock等接口实现对数据的锁定保护。

  - std::lock_guard是C++11提供的锁管理器，可以管理std::mutex，也可以管理其他常见类型的锁。

    std::lock_guard的对锁的管理属于RAII风格用法(Resource Acquisition Is **Initialization**)，在**构造函数**中自动绑定它的互斥体并加锁，在**析构函数**中解锁，大大减少了死锁的风险。

  - std::mutex的成员函数
    - 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。
    - lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。
    - unlock()， 解锁，释放对互斥量的所有权。
    - try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。

# 汇编代码

- ~~~cpp
   __asm { mov dword ptr [ebp-4], 20h
    
  // mov  dword ptr [ebp-4], 10h   mov  是指令，
  // 意思是把数据从“源地址”移动到“目的地址”；
  // 10h  就是“源地址”，只不过这里用了一个常数而不是地址;
  // dword ptr [ebp-4]  就是“目的地址”。
  // 其中，ebp你可以理解为一个指针，ebp-4则是向下4的偏移处（刚好就是nA的地址）。
  // dword ptr意思是把刚才那个偏移处解释为双字指针，即指向4个字节的内存空间的指针。
  ~~~

# 模板元编程

- **C++的模板元编程是使用模板实例化驱动的编译期编程的方式**，这样可以提升代码灵活性及运行期的性能。

- C++模板元编程的优势：

  > - C++的模板参数分为**类型参数template \<class T\>与非类型参数template \<size_t N\>**，其中后者可以用来执行编译期的复杂公式计算（比如gcd递归、斐波拉契数列等），相比于提前自己运算好后直接填值提高可读性，同时保证了计算的正确性以及根据不同的模板参数的灵活性。
  > - **浮点数、类对象以及字符串**是不允许作为非类型模板参数的。非类型的模板参数在编译期就能确认结果。
  >
  > - C++的模板元编程核心时提供一种泛型归类的能力，基于类型萃取、模板、SFINAE等技术灵活为一组特定类型提供代码复用。

- 类模板有全特化和偏特化，但是函数模板只有全特化，不需要偏特化，因为函数有重载，函数模板的偏特化实际上是对于函数模板的重载。可以直接在签名指定类型而不用在模板参数列表\<\>中指定。

- 在模板声明时，参数列表的签名都为typename, 因此相同数量参数的模板声明会被提示重定义。

- SFINAE技术实际上是一种编译保护，有点像运行时的try异常捕捉，不同的模板就是不同的try，基于这种保护机制提供信息。

- `,`逗号表达式会依次计算其左侧和右侧的表达式，然后返回右侧表达式的结果。基于类型萃取中的表达式有效性检查，可以完成SFINAE。

  ~~~cpp
  template<typename T>
  auto process(const T&) -> decltype(std::declval<T>().size(), void()) {
      std::cout << "T has a size() method\n";
  }
  // 这里，decltype 的参数会检查 T 类型是否有 size() 方法。如果没有，编译器会忽略这个模板实例化，而不会报错。
  ~~~

- 对于模板元编程中代码的匹配，在编译开始时，**编译期会执行SFINAE检查**，然后从**检查通过的模板中匹配一个匹配度最高/最具体的模板**；如果没有检查成功的，或者没有能匹配的，就会回退匹配到一个较为通用的模板；如果最终没有能够匹配的，就会报错。

  > 可以被编译期识别为SFINAE条件的有：
  >
  > **函数返回类型的 SFINAE**:
  >
  > - 使用 `std::enable_if` 和 `std::void_t` 可以控制模板的启用与否。条件通常会放在返回类型部分或额外的模板参数中。
  >
  >   ~~~cpp
  >   template<typename T>
  >   std::enable_if_t<std::is_integral_v<T>, void>
  >   process(const T&) {
  >       std::cout << "T is an integral type\n";
  >   }
  >   ~~~
  >
  > **模板参数的 SFINAE**:
  >
  > - 通过添加一个默认模板参数，并将 `std::enable_if` 放置在该参数上，可以控制模板的选择。
  >
  >   ~~~cpp
  >   template<typename T, typename = std::enable_if_t<std::is_class_v<T>>>
  >   void process(const T&) {
  >       std::cout << "T is a class type\n";
  >   }
  >   ~~~
  >
  > **表达式的有效性检查**(一般可以使用逗号表达式):
  >
  > - SFINAE 也可以用来检测某些表达式的有效性，如是否存在某个成员函数、成员变量等。
  >
  >   ~~~cpp
  >   template<typename T>
  >   auto process(const T&) -> decltype(std::declval<T>().size(), void()) {
  >       std::cout << "T has a size() method\n";
  >   }
  >   ~~~

- **模板元编程是对满足某些条件的类型进行代码复用的技术，对于其他不满足条件的类型，如果希望编译直接报错，可以在SFINAE的通用匹配中放置一个固定的错误assert，或者直接对于通用模板声明，但是不给定义。**

  ~~~cpp
  // 通用模板仅声明
  template <system ss>
  systemstatus xxxx();
  
  // 特化模板声明+定义
  systemstaus xxx<xxx>() {};
  ~~~

- 不是所有的模板结构体都有 `value` 静态成员变量。`value` 静态成员变量通常在模板元编程（Template Metaprogramming）中使用，用于表示某个模板结构体或类模板是否满足某种条件。**value为成员常量表达式对象，有些类型萃取结构体模板比如decltype则有type这个类型对象**

  >标准库中定义了value静态成员的模板结构体有：
  >
  >std::is_default_constructible\<T\>::value   // 是否有默认构造
  >
  >std::is_copy_constructible\<T\>::value   // 是否有拷贝构造
  >
  >std::is_copy_assignable\<T\>::value;  // 是否有拷贝赋值
  >
  >std::is_same<decltype(&T::insert), void(T::*)(const T&)  // T是否有insert成员方法（T::\*表示T的成员函数指针），且参数签名为const T&, 返回签名为void.
  >
  >std::is_enum_v<Enum_type> //Enum_type必须是枚举类型
  >
  >template <class T, class... Args> struct is_constructible;  // T是待检查类型，Args是可变参数，这个模板结构体是检查T是否可以被Args构造。
  >
  >std::is_invocable_ v // 这是C++17引入的特性，检查某个方法是否可调用
  >
  >
  >
  >// 基于SFINAE技术检查类型是否具有某方法
  >
  >~~~cpp
  >template<typename T, typename = void>
  >struct Printer {
  >    static void print() {
  >        std::cout << "Default printer\n";
  >    }
  >};
  >
  >// 针对具有 `size` 成员函数的特化
  >template<typename T>
  >struct Printer<T, std::void_t<decltype(std::declval<T>().size())>> {
  >    static void print() {
  >        std::cout << "Type has size() method\n";
  >    }
  >};
  >// 根据decltype是否能编译成功，驱动模板实例化的选择，从而派发生成不同的代码。
  >// 基于std::is_same_v比基于SFINAE技术的检查更加严格，前者除了要求编译成功外，还对函数签名等提出了要求
  >~~~

- 在C++14标准中，可以灵活使用”，“逗号表达时，SFINAE，和std中已经定义的一些模板结构体进行meta program，注意static_assert和if constexpr() 需要得到值（value）， 常用需求如下

  > // 1 模板T是否具有.invoke方法
  >
  > 如果要同时指定方法的签名和返回值：std::is_same_v\<decltype(&T::insert), void(T::*)(const T&)\>  

- ~~~cpp
  decltype 是 C++11 中引入的关键字，用于推断表达式的类型。它的语法如下：
  decltype(expression)
  // 其中 expression 是一个表达式，decltype(expression) 将返回 expression 的类型。具体来说，decltype 会在编译时分析表达式，并确定其类型，而不会实际计算表达式。
  static_assert(std::is_same<decltype(&T::size), size_t(T::*)()>::value, "T must have size()");
  ~~~

  比如上面的例子，decltype(&T::insert)会推断表达式的返回类型，自身表达式类型（T::*表示该表达式为T的成员函数指针），函数参数签名。

- 要注意区分函数模板和类型模板

  >- SFINAE：一般要使用类型模板特化执行SFINAE检查
  >
  >- 特化模板函数时，你需要指定确切的类型参数。此外，函数模板特化的语法是不同的，它不能像类模板特化那样工作。
  >
  >- 在 C++ 中，`::value` 是一个常量表达式，通常与类型特征（type traits）一起使用。`::value` 是许多标准库类型特征（如 `std::true_type` 和 `std::false_type`）的一部分，它表示该类型的某个特定值。
  >
  >- `::value` 是一个静态成员常量，表示一个编译时常量。这使得你可以在 `static_assert` 中进行编译时检查。
  >
  >  **与模板和类型特征结合**：通常与类型特征类（如 `std::true_type`、`std::false_type`、`std::integral_constant`）结合使用，用于在编译时评估条件。

- `std::declval` 是一个 C++ 标准库函数模板，用于产生一个特定类型的临时值。它的语法如下：

  ```cpp
  template <typename T>
  typename std::add_rvalue_reference<T>::type declval() noexcept;
  ```

  `std::declval` 通常用于模板元编程中，特别是在需要推断表达式的类型但又不需要实际执行表达式的情况下。它提供了一种安全的方式来获取任意类型的右值引用。在很多情况下，它用于定义 SFINAE（Substitution Failure Is Not An Error）友好的模板函数或者类模板。

  举个例子，假设您有一个模板函数，需要对某个类型 `T` 的对象调用一个成员函数 `foo()`，但您不知道 `T` 是否真的有这个成员函数。您可以使用 `std::declval` 来获取一个临时值，然后调用这个成员函数，这样可以使得编译器能够进行类型推断，而不会因为尝试调用不存在的成员函数而导致编译错误。

- **`std::declval<U>()`**: 用于生成类型 `U` 的值对象。

  **`std::declval<U&>()`**: 用于生成类型 `U` 的引用对象。

- ~~~cpp
  decltype(std::begin(std::declval<U&>()), std::true_type{})
  中，”，“运算符返回后一个表达式的值
  ~~~

- value_type: 每个STL中的类都有value_type这种东西，通俗的说value_type 就是stl容器盛装的数据的数据类型

- `mapped_type` 是在 C++ 的关联容器（例如 `std::map` 和 `std::unordered_map`）中使用的一个类型定义。它表示容器中存储的“值”的类型。key_type是存储的键类型。

- `std::true_type{}` 是 C++ 标准库中的一个类模板，用于表示==编译期常量 `true`== 的类型。它是一个空结构体，用于在编译时进行类型推断和模板特化。

  具体地说，`std::true_type{}` 创建了一个匿名的 `std::true_type` 类型的临时对象。`std::true_type` 类型只有一个静态成员变量 `value`，其值为 `true`，用于表示一个编译期常量 `true`。

  **true_type，false_type：代表类型（类/结构体类型）
  true,false：代表值
  而bool既可以代表true也可以代表false。而true_type类型代表的就是true，false_type类型代表的就是false.**

  ==可以理解为更精确的类型，而不需要运行时确定，编译器就确认了true还是false。==

- 使用 SFINAE （Substitution failure is not an error 匹配失败不是一个错误）技术来检查类型是否具有 begin() 和 end() 成员函数

  ~~~cpp
  static_assert(decltype(std::declval<C>().begin(), std::true_type{})::value)
  // 在模板元编程中，std::declval 通常与 decltype 结合使用，以获取表达式的类型，而不需要实际创建对象。
  // 如果容器类型 C 没有 begin() 成员函数，使用 std::declval<C>().begin() 将会导致编译时错误。这是因为在模板推导过程中，编译器会尝试调用 begin() 成员函数，并根据返回值推导出 decltype(std::declval<C>().begin()) 的类型。如果 C 类型没有定义 begin() 成员函数，那么这个调用将会导致编译错误，因为编译器无法确定 begin() 的返回类型。
  ~~~

- `std::begin()` 在 C++11 中引入，它是用于泛型编程的重要工具，使得代码能够更加通用，并且能够方便地处理不同类型的容器和数组。

- 从容器中拿到容器内元素类型

  ~~~cpp
  using type = typename std::decay<decltype(*std::begin(std::declval<Container>()))>::type;
  
  // 在 C++ 中，当您使用 `typename` 关键字时，它用于告诉编译器后面的表达式是一个类型名称，而不是一个值或者成员名称。在模板中，有时候我们需要使用 `typename` 来指明某个表达式是一个类型，以帮助编译器正确解析模板代码。
  ~~~

- 模板特化要与对应的模板放在同一个命名空间下，比如如果要对std::hash进行模板特化，则该特化不能在自定义命名空间内进行，必须放在同一命名空间的同一级下

  ~~~cpp
  namespace std
  {
      template<>
      struct std::hash<CurveLogicalId>
      {
          size_t operator()(const CurveLogicalId& id)
          {
              return ...
          }
      }
  }
  ~~~


- 在 C++ 中，宏参数可以传入枚举值，但不能直接传入枚举类型。宏是在预处理阶段展开的，而枚举类型是在编译阶段才会被解析的，所以宏无法直接操作枚举类型。

  ~~~cpp
  enum class A
  {
      a,
      b,
      c
  };
  只能传入A::a, 而不能直接传入A。因为枚举类型在预处理阶段不会被解析。
  ~~~

- 枚举本质上是一个有作用域的数字集，本质是数字，或者只有枚举这个概念，要在编译期得到枚举名需要额外的编写反射机制代码。

  只能使用std::is_enum判断某枚举器是否为枚举

- static_assert在全局命名空间内，而不在std内，**因此要使用的话可以直接使用static_assert, 不要用std::static_assert**。对于C++11，14的static_assert，必须要加上字符串报错提示，在17之后才可以不用。

- `std::remove_reference`是C++标准库 `<type_traits> `头文件中的一个类型萃取工具，用于从一个类型中移除引用（Reference）特性。它返回一个新的类型，该类型是从原始类型中移除了引用特性后得到的。

  具体来说，如果输入的类型T是一个引用类型，即T存在引用特性，则std::remove_reference\<T\>::type将返回T去除引用特性后的类型；否则，返回的类型与T相同。

- 在C++中，`decltype(nullptr)` 用于推导 `nullptr` 的类型，它是 `std::nullptr_t`。`std::nullptr_t` 是一个特殊的类型，用于表示空指针常量 `nullptr`。

  如果一个函数以 `decltype(nullptr)` 作为参数类型，那么该函数的参数类型就是 `std::nullptr_t`。这意味着该函数只能接受 `nullptr` 作为参数。这样的函数设计通常用于区分重载函数，或者用于特定场景下只能接受 `nullptr` 参数的情况。

  **通过接受 `std::nullptr_t` 类型的参数，可以明确区分出哪些函数是专门用于处理 `nullptr` 的，从而避免与其他类型参数的函数发生混淆。**

  ==模板类里面只有重载，没有成员函数的SFINAE，因为无法判断希望重载还是==

- `std::default_delete` 是 C++ 标准库中的一个类模板，用于删除动态分配的对象。它是智能指针（如 `std::unique_ptr`）的默认删除器。这个类模板位于 `<memory>` 头文件中。

  `std::default_delete` 的作用是提供一个删除器，它会在智能指针销毁时自动调用 `delete` 操作符来释放所管理的对象的内存。

  以下是 `std::default_delete` 的一些关键特性和用法：

  1. **默认删除器**：当 `std::unique_ptr` 被创建时，如果没有指定删除器，`std::default_delete` 会被默认使用。
  2. **支持数组删除**：`std::default_delete` 有针对单个对象和数组对象的特化版本，可以安全地删除使用 `new` 分配的对象和使用 `new[]` 分配的数组。
  3. **模板参数**：
     - `T`：表示要删除的对象的类型。

- 【SFINAE】

  - SFINAE本质上是一种编译期分支逻辑的实现方式。
  - SFINAE（std::enable_if）只支持**函数返回值**，**模板参数**和**类型参数**，需要注意的是类模板中的模板函数带有重载语义，因此对于void返回类型的函数，最好不要用函数返回值重载。
  - 【类模板】类模板里面可以根据需要做模板函数，但最好单独声明template \<typename U = T\>。==需要注意SFINAE的分支逻辑只支持模板函数，如果模板类中基于类型不同提供不同的成员函数，要把成员函数写成模板函数==
  - 【类模板】在对类模板中写指针构造时，注意空指针需要单独重载，参数直接写decltype(nullptr)就好。
  - 【类模板，Exceptional C++】**模板构造函数永远都不能成为拷贝构造函数”。所以模板构造函数永远不能取代拷贝构造函数，即便有了模板构造函数，默认拷贝构造函数还是会合成的。**
  - 【类模板与函数模板】类模板的SFINAE只有基于偏特化的实例化，换句话说只能由一个模板声明！函数模板可以根据不同的参数进行重载实现SFINAE，包括类型参数、模板参数和（返回值？==有疑问==）

- 【模板类，模板基类】

  - 派生类会默认继承基类的**非私有成员函数**。但是，派生类**不会自动继承**基类的构造函数、拷贝构造函数和赋值运算符，除非显式地使用 `using` 语句来显式继承它们。【另外编译期会分别自动生成默认构造函数（除非显式定义了构造函数）、拷贝/移动构造函数（除非显式定义了拷贝构造）以及拷贝/移动赋值函数（除非显式定义了拷贝/移动赋值）】
  - 同时考虑到拷贝构造函数永远不能模板化，因此与模板类有类型分支拷贝构造时，可以利用类模板的SFINAE完成
  - **重载函数选择(Overload resolution)动作要先于存取权限检查(access checking)。**编译器并不因为模板函数是private而在重载匹配选择时忽略它，可见是先进行重载选择，接下来判断可见性。

# 常见hash函数

- 两个int可以被hash为一个long

  ~~~cpp
  public static long HashToLong(int n1, int n2)
  {
     long ret = n1;
     ret <<= 32;
     ret += n2;
     return ret;
  }
  ~~~

- 在boost::hash_combine模板函数中使用一个已有的hash种子seed和一个新的可被hash的对象obj，以此得到组装的hash

  ~~~cpp
  seed ^= hash_value(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
  ~~~

  - 其中’+‘法可以将相似的值映射到很远，从而探测hash表不会崩溃
  - 0x9e3779b9是一个魔法数字，标识一个32位的随机比特值，其中bite值每一位都有均等的可能为0或者1。要得到这样一个随机比特值的一种常见方法是二进制展开一个无理数。在这样的思想下，该数字是黄金比例分支数的倒数（除数为$2^{32}$）。
  - 在这样的映射方法中，相似的值都会被映射到很远。

- 两个int或者一个数组和一个int可以使用移位hash

  ~~~cpp
  public static long hashCombine(int n1, int n2)
  {
     auto hash1 = std::hash<int>()(n1);
     auto hash2 = std::hash<int>()(n2);
     return hash1 ^ (hash2 << 1);
  }
  ~~~

  

- 乘法hash，除法hash，标识hash（直接使用整数的键值作为hash值），移位hash

# C++宏

- \_\_VA_ARGS\_\_为可变参数宏，实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。这样预定义宏\_ _VA\_ARGS\_\_就可以被用在替换部分中，替换省略号所代表的字符串。==注意当可变参数量可能为0时，加##用来支持0个可变参数的情况。（仅用于纯字符串的处理）==比如下：

  ~~~cpp
  使用预定义的宏，来承载接受...可变参数输入的变量，在宏体(macro body)中，再展开赋值后的预定义宏__VA_ARGS__标识符，从而实现可变参数宏函数。无论是__VA_ARGS__还是args...核心都是给可变参数一个名字
  至于加上##可以支持0个可变参数，可以理解为原来不知道可变参数是有还是无，无法确认再将可变参数视为整体后，整体有多少个参数（可能为n，可能为n+1）；加上##强行将前部分参数和后面位置的可变参数连接为一个字符串，然后编译器在函数体以逗号为分隔符解析，可以处理0个可变参数的情况。
  
  #include<stdio.h> 
  
  #define PRINT_DBG(debug, ...)\ 
  {\ 
      if(debug) {\ 
      fprintf(stderr, "%s %s [%d]: ", __FILE__, __FUNCTION__, __LINE__);\ 
      fprintf(stderr, __VA_ARGS__);\ 
      }\ 
  } 
  #define MACRO(s, ...) printf(s, ##__VA_ARGS__) 
  // 如果可变参数被忽略或为空，## 操作将使预处理器 (preprocessor) 去除掉它前面的那个逗号。
  宏的可变参数主要还是用于基本数据的输出
  
  
  int main() 
  { 
  int i =100; 
  PRINT_DBG(1,"hello\n"); 
  PRINT_DBG(1,"world, %d\n",i); 
  MACRO("hello, world\n"); //这里没有可变参数， 所以要用##__VA_ARGS__ 
  MACRO("hello, %s\n", "fanrey"); 
  return 0; 
  } 
  ~~~

- \_\_LINE\_\_：在源代码中插入当前源代码行号；
- \_\_FILE\_\_: 在源文件中插入当前源文件名；
- \_\_DATA\_\_: 在源文件**插入当前编译日期**；
- \_\_TIME\_\_: 在源文件中插入**当前编译时间**；
- \_\_STDC\_\_: 当要求程序严格遵循ANSI C标准时该标识被赋值为1；
- \_\_cplusplus: 当编写C++程序时该标识符被定义

> 作用：帮助我们完成跨平台的代码编写，同时巧妙使用也可以帮助输出有用的调试信息

- **当##遇到后面是可变参数的时候，编译器的预处理器会特殊处理**，例如：#define XNAME(n) ,##n这样的宏编译会出错，但是改成#define XNAME(n...) ,##n之后编译就会通过，这是预处理做了特殊处理，我们并不知道编译器设计者如何去实现的，但是我们应该知道这个特殊的应用场景。
- C++中，需要以逗号或者其他标识符作为参数之一时，为避免解析问题，可以专门定义一个宏。\#define COMMA , #define MACRO(a, b) \    std::cout << "a: " << a << ", b: " << #b << std::endl; int main() {    MACRO(a, COMMA);  // 调用宏，传入 a 和逗号 }
- 【宏展开特性，递归宏，惰性展开】**宏防止自身递归**：当一个宏正在展开时，它不会在同一轮展开中递归调用自身。这就是为什么在递归宏展开时，第二次调用 `A(__VA_ARGS__)` 没有被展开；**惰性展开**：宏的展开是惰性的，C++预处理器不会立即递归展开所有内容，除非在后续步骤中需要它。**一般为了让宏递归展开，需要辅助宏强制展开，EXPAND(X) X**
- 【宏函数，宏参数展开方式】**实参代入宏文本后，实参之前或之后遇到#或##，实参不再展开**。如果没有，则先展开再进行带入。

# C++文件操作

- 使用#include <fstream>头文件进行文件操作

- 当创建ofstream对象后，可以像操作cout一样操作此对象，**重载的插入操作符<<**

- 当创建ifstream对象后，可以像操作cin一样操作此对象，**即重载的插入操作符>>**

- ofstream文件写，从内存写入存储设备；ifstream文件读，存储设备读入内存；fstream文件读写

- 在fstream类中，成员函数open()实现打开文件的操作，从而将数据流和文件进行关联，通过ofstream、ifstream和fstream对象进行对文件的读写

- 
  public member function

  void open ( const char * filename,ios_base::openmode mode = ios_base::in | ios_base::out );

  | ios::in     | 为输入(读)而打开文件         |
  | ----------- | ---------------------------- |
  | ios::out    | 为输出(写)而打开文件         |
  | ios::ate    | 初始位置：文件尾             |
  | ios::app    | 所有输出附加在文件末尾       |
  | ios::trunc  | 如果文件已存在则先删除该文件 |
  | ios::binary | 二进制方式                   |

  ofstream 在打开文件时**默认清空文件所有内容**。如果使用 ios::app 来打开文件，虽然不会清空文件内容，但是每次写操作都追加到文件末尾。

# C++数值处理

- 三维向量的叉积，模、方向、坐标

  ![image-20230410150458022](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20230410150458022.png)

- C++将计算得到的数字字符串化，可以使用std::to_string(double).需要注意的时该方法只能精确到六位小数点

- C++string类型字符串添加字符：
  - push_back() 比如str1.push_back('y')
  - \+ 比如 str = str+'a'或str+='a'
  - append 这个可以直接添加字符串比如str1.append("China")

- C++的fabs()为求双精度浮点数的绝对值

- C++将中间计算结果保留两位有效数字，可以如下：

  double CPURate = 20.3822;
  	//保留小数点后两位
  	CPURate = (int)(100.0 * CPURate + 0.5) / 100.0;
  	cout << CPURate << endl;     //20.38
      //保留小数点后一位
  	CPURate = (int)(10.0 * CPURate + 0.5) / 10.0;
  	cout << CPURate << endl;     //20.4

  或者利用round函数四舍五入变整型**总的来说就是，要保留几位小数就先乘以十的多少次方后int化，之后相应的再除以10的这么多次方的double类型**

- C++浮点数转为字符串，并保留一定小数位数

  - 使用std::stringstream做字符串流的输入输出工作

    std::ostringstream oss;

    oss<<std::setprecision(fixed)<<val;  // setprecision保证数值被精确到小数点后fixed位

    return oss.str(); //直接使用.str()从流中取出字符串，说白了就是利用一个流对象作为中转使用setprecision控制小数位数

  - 使用std::to_string + 求子串

    **to_string不支持指定格式化小数的位数，所有数字都被扩为小数点后六位进行string转化**，因此为了格式化，可以在后面求子串

    auto str = std::to_string(val);

    return str.substr(0, str.find(".")+fixed+1)


# C++代码安全与规范

- 使用gsl::span保证char数组不越界，而不是通过代码检查。
- 不提倡在.h文件中使用匿名命名空间，因为.cpp/.cc才是编译单元。而一个.h文件可能被多个cpp文件调用，如果在.h文件中使用了匿名命名空间，虽然其是内联的，但在被多个.cpp文件引用时，编译器仍然会为这个匿名的命名空间在不同的.cpp中生成不同的唯一空间名字，这意味着如果在.h中声明了一个类型，那在不同的cpp中将会看到不同的类型名字，比如其在编译单元src1.cpp的内部名字是==::a0b2de::LocalType==，在编译单元src2.cpp的内部名字是==::d3fe23d:: LocalType==。
- ![image-20230418141245397](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20230418141245397.png)

# C++编译

[C++编译链接](D:\Project\StudyNotes\编译相关)

# C++调试运维

# C++程序执行过程

1. 程序加载：操作系统加载

程序到内存。

2. 全局静态变量初始化
3. main函数执行

**comment：**定义在cpp文件的全局静态变量的初始化时机是在程序启动时，并且是在main函数执行之前。具体初始化的顺序取决于它们在文件中的顺序和是否跨翻译单元。跨翻译单元的初始化顺序是不确定的，应该避免依赖。
